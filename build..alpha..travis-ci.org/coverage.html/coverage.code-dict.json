{"/home/travis/build/npmtest/node-npmtest-lmd/test.js":"/* istanbul instrument in package npmtest_lmd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-lmd/lib.npmtest_lmd.js":"/* istanbul instrument in package npmtest_lmd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_lmd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_lmd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-lmd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-lmd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_lmd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_lmd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_lmd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_lmd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_lmd.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_lmd.__dirname + '/lib.npmtest_lmd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_builder.js":"/**\n * LMD Builder\n *\n * @author  Mikhail Davydov\n * @licence MIT\n */\n\nvar fs = require('fs'),\n    inherits = require('util').inherits,\n    path = require('path'),\n    uglifyCompress = require(\"uglify-js\"),\n    csso = require('csso'),\n    SourceMapGenerator = require('source-map').SourceMapGenerator,\n    SourceMapConsumer = require('source-map').SourceMapConsumer,\n    colors = require('colors'),\n    parser = uglifyCompress.parser,\n    uglify = uglifyCompress.uglify,\n    DataStream = require(__dirname + '/../lib/data_stream.js'),\n    lmdCoverage = require(__dirname + '/../lib/coverage_apply.js'),\n    common = require(__dirname + '/../lib/lmd_common.js'),\n    Writer = require(__dirname + '/../lib/lmd_writer.js'),\n    Cli = require(__dirname + '/cli_messages.js'),\n    assembleLmdConfig = common.assembleLmdConfig;\n\nvar LMD_JS_SRC_PATH = common.LMD_JS_SRC_PATH;\nvar LMD_PLUGINS = common.LMD_PLUGINS;\n\n/**\n * LmdBuilder LMD Package Builder\n *\n * LmdBuilder is readable stream\n * \n * @constructor\n *\n * @inherits Stream\n *\n * @param {String} configFile\n * @param {Object} [options]\n *\n * @example\n *\n *      new LmdBuilder(\"config.json\", {\n *          warn: true\n *      })\n *      .pipe(process.stdout);\n */\nvar LmdBuilder = function (configFile, options) {\n    DataStream.call(this);\n    this.options = options || {};\n    var self = this;\n\n    // apply config\n    this.configFile = configFile;\n\n    this.init();\n\n    // Bundles streams\n    this.bundles = {};\n\n    // Let return instance before build\n    this.buildConfig = this.compileConfig(configFile, self.options);\n\n    this.makeEmptyStreamsUnreadable(this.buildConfig);\n\n    var isFatalErrors = !this.isAllModulesExists(this.buildConfig);\n    if (isFatalErrors) {\n        this.readable = false;\n        this.style.readable = false;\n        this.sourceMap.readable = false;\n    } else {\n        this._initBundlesStreams(this.buildConfig.bundles);\n    }\n    process.nextTick(function () {\n        if (!isFatalErrors) {\n            if (configFile) {\n                var buildResult = self.build(self.buildConfig);\n\n                self.write(buildResult.source);\n                self.style.write(buildResult.style);\n                self.sourceMap.write(buildResult.sourceMap.toString());\n                self._streamBundles(buildResult.bundles);\n            } else {\n                self.log.write('lmd usage:\\n\\t    ' + 'lmd'.blue + ' ' + 'config.lmd.js(on)'.green + ' [output.lmd.js]\\n');\n            }\n        } else {\n            self.printFatalErrors(self.buildConfig);\n        }\n        self.closeStreams();\n    });\n};\n\n/**\n * LMD Package Watcher\n *\n * @constructor\n *\n * @inherits Stream\n *\n * @param {String} configFile\n * @param {Object} [options]\n *\n * @example\n *\n *      new LmdBuilder.watch(\"config.json\", {\n *          warn: true\n *      })\n *      .log.pipe(process.stdout);\n */\nLmdBuilder.watch = function (configFile, options) {\n    DataStream.call(this);\n    this.options = options || {};\n    var self = this;\n\n    this.configFile = configFile;\n\n    this.init();\n    this.sourceMap.readable = false;\n    this.readable = false;\n\n    // Let return instance before build\n    this.watchConfig = this.compileConfig(self.configFile, self.options);\n\n    this.makeEmptyStreamsUnreadable(this.watchConfig);\n\n    var isFatalErrors = !this.isAllModulesExists(this.watchConfig);\n    if (isFatalErrors) {\n        this.readable = false;\n    }\n    process.nextTick(function () {\n        if (!isFatalErrors) {\n            if (!configFile) {\n                return;\n            }\n\n            if (typeof self.watchConfig.output === 'string') {\n                self.fsWatch(self.watchConfig);\n                return;\n            } else {\n                self.log.write('ERRO'.red.inverse + ':' + '    Check your config file. \"output\" parameter should be a {String} eg \"../path\"'.red + '\\n');\n                return;\n            }\n        } else {\n            self.printFatalErrors(self.watchConfig);\n        }\n        self.closeStreams();\n    });\n};\n\ninherits(LmdBuilder, DataStream);\n// Share prototype\nLmdBuilder.watch.prototype = LmdBuilder.prototype;\n\n/**\n * Applies defaults\n *\n * @param {Object} options\n *\n * @return {Object}\n */\nLmdBuilder.prototype.defaults = function (options) {\n    options = options || {};\n\n    if (typeof options.warn === \"undefined\") {\n        options.warn = true;\n    }\n\n    if (typeof options.log === \"undefined\") {\n        options.log = true;\n    }\n\n    if (typeof options.output === 'undefined') {\n        options.output = false;\n    }\n\n    if (typeof options.styles_output === 'undefined' && typeof options.output === 'string') {\n        options.styles_output = path.join(\n            path.dirname(options.output),\n            path.basename(options.output, path.extname(options.output)) + '.css'\n        );\n    }\n\n    if (typeof options.bundles_callback === 'undefined') {\n        options.bundles_callback = '_' + Math.round(Math.random() * 0xFFFFFFFF).toString(16);\n    }\n\n    Object.keys(options.bundles || {}).forEach(function (name) {\n        options.bundles[name].bundles_callback = options.bundles_callback;\n    });\n\n    return options;\n};\n\n/**\n * Common init for LmdBuilder and LmdBuilder.watch\n */\nLmdBuilder.prototype.init = function () {\n    this._closeStreams = this.closeStreams.bind(this);\n\n    this.configDir = path.dirname(this.configFile);\n    this.flagToOptionNameMap = LMD_PLUGINS;\n\n    /**\n     * Build log\n     *\n     * @type {Stream}\n     */\n    this.log = new DataStream();\n\n    /**\n     * Source Map\n     *\n     * @type {Stream}\n     */\n    this.sourceMap = new DataStream();\n\n    /**\n     * Style\n     *\n     * @type {Stream}\n     */\n    this.style = new DataStream();\n\n    process.once('exit', this._closeStreams);\n};\n\n/**\n * Makes empty streams unreadable\n * @param config\n */\nLmdBuilder.prototype.makeEmptyStreamsUnreadable = function (config) {\n    // modules\n    this.readable = this._has(config, 'modules');\n\n    // source map\n    this.sourceMap.readable = this._has(config, 'modules');\n\n    // styles\n    this.style.readable = this._has(config, 'styles');\n};\n\n/**\n *\n * @param configFile\n * @param options\n */\nLmdBuilder.prototype.compileConfig = function (configFile, options) {\n    return this.defaults(assembleLmdConfig(configFile, Object.keys(this.flagToOptionNameMap), options));\n};\n\n/**\n *\n * @param buildConfig\n * @return {Boolean}\n */\nLmdBuilder.prototype.isAllModulesExists = function (buildConfig) {\n    var self = this;\n    var modules = buildConfig.modules || {},\n        bundles = buildConfig.bundles || {},\n        styles = buildConfig.styles || [],\n        bundle;\n\n    for (var moduleName in modules) {\n        if (!modules[moduleName].is_exists) {\n            return false;\n        }\n    }\n\n    for (var i = 0, c = styles.length; i < c; i++) {\n        if (!styles[i].is_exists) {\n            return false;\n        }\n    }\n\n    // Check bundles and sub-bundles\n    for (var bundleName in bundles) {\n        bundle = bundles[bundleName];\n        if (bundle instanceof Error) {\n            return false;\n        }\n\n        var isModulesExists = Object.keys(bundles).every(function (bundleName) {\n            return self.isAllModulesExists(bundles[bundleName]);\n        });\n\n        if (!isModulesExists) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n/**\n *\n * @param buildConfig\n */\nLmdBuilder.prototype.printFatalErrors = function (buildConfig) {\n    var modules = buildConfig.modules || {},\n        bundles = buildConfig.bundles || {},\n        styles = buildConfig.styles || {},\n        bundle,\n        projectRoot = buildConfig.path || buildConfig.root,\n        errorMessage;\n\n    for (var moduleName in modules) {\n        if (!modules[moduleName].is_exists) {\n            errorMessage = 'Module \"' + moduleName.cyan + '\": \"' +\n                modules[moduleName].originalPath.toString().red;\n            errorMessage += '\" (';\n            // check multi path modules\n            errorMessage += [].concat(modules[moduleName].path).map(function (path) {\n                return String(path)[fs.existsSync(path) ? 'green' : 'red'];\n            }).join(', ');\n            errorMessage += ') is not exists. Project root: \"' + String(projectRoot).green + '\". ';\n\n            this.error(errorMessage);\n        }\n    }\n\n    for (var i = 0, c = styles.length; i < c; i++) {\n        if (!styles[i].is_exists) {\n            errorMessage = 'Style (' +\n                styles[i].path.toString().red + ') is not exists. ' +\n                'Project root: \"' + String(projectRoot).green + '\". ';\n\n            this.error(errorMessage);\n        }\n    }\n\n    // Check bundles and sub-bundles\n    for (var bundleName in bundles) {\n        bundle = bundles[bundleName];\n        if (bundle instanceof Error) {\n            errorMessage = 'Bundle \"' + bundleName.cyan + '\": (' +\n                bundle.message.red + ') is not exists. ' +\n                'Project root: \"' + String(projectRoot).green + '\". ';\n\n            this.error(errorMessage);\n        } else {\n            // check modules of bundle\n            this.printFatalErrors(bundle);\n        }\n    }\n};\n\n/**\n * Closes all streams and make it unreadable\n */\nLmdBuilder.prototype.closeStreams = function () {\n    this.end();\n    this.log.end();\n    this.style.end();\n    this.sourceMap.end();\n\n    this._closeBundleStreams();\n    process.removeListener('exit', this._closeStreams);\n};\n\n/**\n * LMD template\n * \n * @param {Object} data\n */\nLmdBuilder.prototype.templatePackage = function (data) {\n    return (data.build_info ? data.build_info + '\\n' : '') +\n    data.lmd_js +\n    '\\n(' +\n        data.global + ',' +\n        data.lmd_main + ',' +\n        data.lmd_modules + ',' +\n        data.modules_options + ',' +\n        data.options +\n    ');\\n';\n};\n\n/**\n * LMD template\n *\n * @param {Object} data\n * @param {Object} data.bundles_callback\n * @param {Object} data.build_info\n * @param {Object} data.lmd_main\n * @param {Object} data.lmd_modules\n * @param {Object} data.modules_options\n */\nLmdBuilder.prototype.templateBundle = function (data) {\n    return (data.build_info ? data.build_info + '\\n' : '') +\n    data.bundles_callback + '(' +\n        (data.lmd_main ? data.lmd_main + ',' : '') +\n        data.lmd_modules + ',' +\n        data.modules_options +\n    ');\\n';\n};\n\n/**\n * Compress code using UglifyJS\n * \n * @param {String}  code\n * @param {Object}  pack_options\n * @param {Boolean} pack_options.strict_semicolons\n * @param {Object}  pack_options.mangle_options\n * @param {Object}  pack_options.squeeze_options\n * @param {Object}  pack_options.gen_options\n *\n * @returns {String} compressed code\n */\nLmdBuilder.prototype.compress = function (code, pack_options) {\n    pack_options = typeof pack_options === \"object\" ? pack_options : {};\n    return uglifyCompress(code, pack_options);\n};\n\n/**\n * Optimizes lmd code\n *\n * @param {String} lmd_js_code\n *\n * @returns {String}\n */\nLmdBuilder.prototype.optimizeLmdSource = function (lmd_js_code) {\n    var walker = uglify.ast_walker();\n\n    /**\n     * Uses variable sandbox for create replacement map\n     *\n     * @param {Object} ast toplevel AST\n     *\n     * @return {Object} {name: replaceName} map\n     */\n    function getSandboxMap(ast) {\n        var map = {};\n\n        walker.with_walkers({\n            // looking for first var with sandbox item;\n            \"var\" : function (vars) {\n                for (var i = 0, c = vars.length, varItem; i < c; i++) {\n                    varItem = vars[i];\n                    if (varItem[0] === 'sandbox') {\n                        varItem[1][1].forEach(function (objectVar) {\n                            map[objectVar[0]] = objectVar[1][1];\n                        });\n                        throw 0;\n                    }\n                }\n            }\n        }, function () {\n            try {\n                return walker.walk(ast);\n            } catch (e) {}\n        });\n\n        return map;\n    }\n\n    /**\n     * Brakes sendbox in one module\n     *\n     * @param {Object} ast\n     * @param {Object} replaceMap\n     *\n     * @return {Object} call AST\n     */\n    function breakSandbox(ast, replaceMap) {\n        var sandboxName = ast[2][0] || 'sb';\n\n        var newAst = walker.with_walkers({\n            // lookup for dot\n            // looking for this pattern\n            // [\"dot\", [\"name\", \"sb\"], \"require\"] -> [\"name\", map[\"require\"]]\n            \"dot\" : function () {\n                if (this[1] && this[1][0] === \"name\" && this[1][1] === sandboxName) {\n                    var sourceName = this[2];\n                    return [\"name\", replaceMap[sourceName]];\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n\n        // remove IEFE's `sb` or whatever argument\n        newAst[1][2] = [];\n\n        return newAst;\n    }\n\n    /**\n     * Brake sandbox: Using UglifyJS AST and sandbox variable in lmd.js file\n     * replace all sb.smth with actual value of sandbox[smth]\n     * than delete sandbox variable from lmd.js and all modules\n     *\n     * @param {Object} ast\n     *\n     * @returns {Object} toplevel AST\n     */\n    function brakeSandboxes(ast) {\n        var map = getSandboxMap(ast),\n            isSandboxVariableWiped = false;\n\n        return walker.with_walkers({\n            // lookup for modules\n            // looking for this pattern\n            // [ 'call',\n            //  [ 'function', null, [ 'sb' ], [ [Object] ] ],\n            //  [ [ 'name', 'sandbox' ] ] ]\n            \"call\" : function (content) {\n                if (this[2] &&\n                    this[2].length > 0 &&\n                    this[2][0][0] === \"name\" &&\n                    this[2][0][1] === \"sandbox\" &&\n                    this[1] &&\n                    this[1][0] === \"function\"\n                    ) {\n                    // 1. remove sandbox argument\n                    this[2] = [];\n                    // 2. break sandbox in each module\n                    return breakSandbox(this, map);\n                }\n            },\n            // wipe sandobx variable\n            \"var\": function () {\n                if (isSandboxVariableWiped) {\n                    return;\n                }\n\n                for (var i = 0, c = this[1].length, varItem; i < c; i++) {\n                    varItem = this[1][i];\n                    if (varItem[0] === 'sandbox') {\n                        isSandboxVariableWiped = true;\n                        this[1].splice(i, 1);\n\n                        return this;\n                    }\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n    }\n\n    /**\n     * Collects all plugins events with usage and event index\n     *\n     *  {\n     *      eventIndex: 3, // relative event index\n     *      on: 1,         // number of listeners\n     *      trigger: 2     // number of triggers\n     *  }\n     *\n     * @param {Object} ast toplevel AST\n     *\n     * @return {Object} toplevel AST\n     */\n    function getEvents(ast) {\n        var usage = {},\n            eventIndex = 0;\n\n        walker.with_walkers({\n            // looking for first var with sandbox item;\n            \"call\" : function () {\n                if (this[1] && this[2][0]) {\n                    var functionName = this[1][1];\n                    switch (functionName) {\n                        case \"lmd_on\":\n                        case \"lmd_trigger\":\n                            var eventName = this[2][0][1];\n                            if (!usage[eventName]) {\n                                usage[eventName] = {\n                                    on: 0,\n                                    trigger: 0,\n                                    eventIndex: eventIndex\n                                };\n                                eventIndex++;\n                            }\n                            if (functionName === \"lmd_on\") {\n                                usage[eventName].on++;\n                            } else {\n                                usage[eventName].trigger++;\n                            }\n                            break;\n                    }\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n\n        return usage;\n    }\n\n    /**\n     * Wipes lmd_on, lmd_trigger, lmd_events variables from source\n     *\n     * @param {Object} ast\n     *\n     * @return {Object} modified ast\n     */\n    function wipeLmdEvents(ast) {\n        var itemsToWipe = ['lmd_on', 'lmd_trigger', 'lmd_events'];\n\n        return walker.with_walkers({\n            // wipe lmdEvents variables\n            \"var\": function () {\n                if (!itemsToWipe.length) {\n                    return;\n                }\n\n                for (var i = 0, c = this[1].length, varItem; i < c; i++) {\n                    varItem = this[1][i];\n                    if (varItem) {\n                        var itemIndex = itemsToWipe.indexOf(varItem[0]);\n                        if (itemIndex !== -1) {\n                            itemsToWipe.splice(itemIndex, 1);\n                            this[1].splice(i, 1);\n                            i--;\n                        }\n                    }\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n    }\n\n    /**\n     * Optimizes number of lmd_{on|trigger} calls\n     *\n     * @param {Object} ast toplevel AST\n     *\n     * @return {Object} loplevel AST\n     */\n    function reduceAndShortenLmdEvents(ast) {\n        var events = getEvents(ast),\n            isWipeLmdEvents = true;\n\n        for (var eventName in events) {\n            if (isWipeLmdEvents) {\n                if (events[eventName].on !== 0 && events[eventName].trigger !== 0) {\n                    // something is calling events\n                    isWipeLmdEvents = false;\n                }\n            }\n        }\n\n        // If no lmd_trigger and lmd_on calls\n        // than delete them plus lmd_events from lmd.js code\n        if (isWipeLmdEvents) {\n            ast = wipeLmdEvents(ast);\n        }\n\n        ast = walker.with_walkers({\n            // looking for first var with sandbox item;\n            \"call\" : function () {\n                if (this[1] && this[2][0]) {\n                    var functionName = this[1][1],\n                        eventName,\n                        eventDescriptor;\n\n                    switch (functionName) {\n                        case \"lmd_on\":\n                            eventName = this[2][0][1];\n                            eventDescriptor = events[eventName];\n\n                            // if no event triggers (no lmd_trigger(event_name,...))\n                            // delete all lmd_on(event_name,...) statements\n                            if (eventDescriptor.trigger === 0) {\n                                return [\"stat\"]; // wipe statement = return empty statement - ;\n                            }\n\n                            // Shorten event names: Using UglifyJS AST find all event names\n                            // from lmd_trigger and lmd_on and replace them with corresponding numbers\n                            //console.log(this);\n                            this[2][0] = [\"num\", eventDescriptor.eventIndex];\n                            break;\n\n                        case \"lmd_trigger\":\n                            eventName = this[2][0][1];\n                            eventDescriptor = events[eventName];\n\n                            // if no event listeners (no lmd_on(event_name,...))\n                            // replace all lmd_trigger(event_name, argument, argument)\n                            // expressions with array [argument, argument]\n                            if (eventDescriptor.on === 0) {\n                                // if parent is statement -> return void\n                                // to prevent loony arrays eg [\"pewpew\", \"ololo\"];\n                                if (walker.parent()[0] === \"stat\") {\n                                    return [\"stat\"]; // wipe statement = return empty statement - ;\n                                }\n\n                                /*\n                                [\n                                    \"call\",\n                                    [\"name\", \"lmd_trigger\"],\n                                    [\n                                        [\"string\", \"lmd-register:call-sandboxed-module\"],\n                                        [\"name\", \"moduleName\"],\n                                        [\"name\", \"require\"]\n                                    ]\n                                ]\n\n                                  --->\n\n                                [\n                                    \"array\",\n                                    [\n                                        [\"name\", \"moduleName\"],\n                                        [\"name\", \"require\"]\n                                    ]\n                                ]\n                                */\n                                return [\"array\", this[2].slice(1)];\n                            }\n\n                            // Shorten event names: Using UglifyJS AST find all event names\n                            // from lmd_trigger and lmd_on and replace them with corresponding numbers\n                            this[2][0] = [\"num\", eventDescriptor.eventIndex];\n                            break;\n                    }\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n\n        // #52 optimise constant expressions like [main][0]\n        ast = walker.with_walkers({\n            \"sub\": function () {\n                // Looking for this pattern\n                // [ 'sub', [ 'array', [ [Object], [Object] ] ], [ 'num', 1 ] ]\n                if (this[1][0] === \"array\" && this[2][0] === \"num\") {\n\n                    var isConstantArray = this[1][1].every(function (item) {\n                        return item[0] === \"num\" ||\n                               item[0] === \"string\" ||\n                               item[0] === \"name\" ||\n                               item[0] === \"array\" ||\n                               item[0] === \"object\";\n                    });\n\n                    if (isConstantArray) {\n                        var index = this[2][1];\n\n                        /*\n                         [main][0]\n\n                          --->\n\n                         main\n                        */\n\n                        return this[1][1][index];\n                    }\n                }\n            }\n        }, function () {\n            return walker.walk(ast);\n        });\n\n        return ast;\n    }\n\n    var ast = parser.parse(lmd_js_code);\n    ast = brakeSandboxes(ast);\n    ast = reduceAndShortenLmdEvents(ast);\n\n    var code =  uglify.gen_code(ast);\n\n    // wipe tail ;\n    code = this.removeTailSemicolons(code);\n    return code;\n};\n\n/**\n * Removes tail semicolons\n *\n * @param {String} code\n *\n * @return {String}\n */\nLmdBuilder.prototype.removeTailSemicolons = function (code) {\n    return code.replace(/\\n*;$/, '');\n};\n\n/**\n * JSON escaper\n *\n * @param file\n */\nLmdBuilder.prototype.escape = function (file) {\n    return JSON.stringify(file);\n};\n\n/**\n * Module code renderer\n * \n * @param {Array}   config\n * @param {Object}  modulesBundle\n * @param {String}  modulesBundle.main\n * @param {Array}   modulesBundle.modules\n * @param {Object}  modulesBundle.options\n * @param {Boolean} isOptimizeLmd\n *\n * @returns {String}\n */\nLmdBuilder.prototype.renderLmdPackage = function (config, modulesBundle, isOptimizeLmd) {\n    var lmd_js = fs.readFileSync(path.join(LMD_JS_SRC_PATH, 'lmd.js'), 'utf8'),\n        lmd_main = modulesBundle.main,\n        lmd_modules = modulesBundle.modules,\n        modules_options = modulesBundle.options,\n        result;\n\n    // Apply patch if LMD package in cache Mode\n    lmd_js = this.patchLmdSource(lmd_js, config);\n    if (isOptimizeLmd) {\n        lmd_js = this.optimizeLmdSource(lmd_js);\n    }\n    lmd_modules = '{\\n' + lmd_modules.join(',\\n') + '\\n}';\n\n    var options = {},\n        version = config.cache ? config.version : false,\n        stats_host = config.stats_auto || false,\n        promise = config.promise || false,\n        bundle = config.bundle ? config.bundles_callback : false;\n\n    // if version passed -> module will be cached\n    if (version) {\n        options.version = version;\n    }\n\n    if (stats_host) {\n        options.stats_host = stats_host;\n    }\n\n    if (promise) {\n        options.promise = promise;\n    }\n\n    if (bundle) {\n        options.bundle = bundle;\n    }\n\n    var userPlugin;\n\n    for (var userPluginName in config.plugins) {\n        userPlugin = config.plugins[userPluginName];\n        if (userPlugin.isOk && userPlugin.options && !options[userPlugin.name]) {\n            options[userPlugin.name] = userPlugin.options;\n        }\n    }\n\n    options = JSON.stringify(options);\n\n    result = this.templatePackage({\n        build_info: this._getBundleBanner(config),\n        lmd_js: lmd_js,\n        global: config.global || 'this',\n        lmd_main: lmd_main || 'function(){}',\n        lmd_modules: lmd_modules,\n        modules_options: JSON.stringify(modules_options),\n        options: options\n    });\n\n    return result;\n};\n\n/**\n * Styles renderer\n *\n * @param {Array}   styles\n * @param {Boolean} isOptimizeCss\n *\n * @returns {String}\n */\nLmdBuilder.prototype.renderStyles = function (styles, isOptimizeCss) {\n    if (!styles || !styles.length) {\n        return '';\n    }\n\n    var allCss = styles\n        .filter(function (style) {\n            return style.is_exists;\n        })\n        .map(function (style) {\n            return fs.readFileSync(style.path, 'utf8');\n        })\n        .join('\\n');\n\n    return isOptimizeCss ? csso.justDoIt(allCss, true) : allCss;\n};\n\n/**\n * Module code renderer\n *\n * @param {Array}   config\n * @param {Object}  modulesBundle\n * @param {String}  modulesBundle.main\n * @param {Array}   modulesBundle.modules\n * @param {Object}  modulesBundle.options\n *\n * @returns {String}\n */\nLmdBuilder.prototype.renderLmdBundle = function (config, modulesBundle) {\n    return this.templateBundle({\n        lmd_main: modulesBundle.main,\n        bundles_callback: config.bundles_callback,\n        build_info: this._getBundleBanner(config),\n        lmd_modules: '{\\n' + modulesBundle.modules.join(',\\n') + '\\n}',\n        modules_options: JSON.stringify(modulesBundle.options)\n    });\n};\n\nLmdBuilder.prototype._getBundleBanner = function (config) {\n    // If exists return\n    if (typeof config.banner === 'string') {\n        return config.banner;\n    }\n\n    // Else create default\n    var configFile = path.basename(this.configFile),\n        mixinFiles = (config.mixins || []).map(function (mixin) {\n            return path.basename(mixin);\n        });\n\n    return '// This file was automatically generated from \"' + configFile + '\"' +\n            (mixinFiles.length ? ' using mixins \"' + mixinFiles.join('\", \"') + '\"' : '');\n};\n\n/**\n * Patches lmd source\n *\n * @param {String}  lmd_js\n * @param {Object} config\n *\n * @returns {String}\n */\nLmdBuilder.prototype.patchLmdSource = function (lmd_js, config) {\n    var optionNames,\n        flagName;\n\n    /**\n     * Applies or removes block from lmd_js\n     *\n     * @param {String} optionName block name eg $P.CACHE\n     * @param isApply  apply or remove block\n     * @param isInline block is inline (based on block comment)\n     *\n     * @returns {Boolean} true if block was found, false - not found\n     */\n    var preProcessBlock = function (optionName, isApply, isInline) {\n        // /*if ($P.CSS || $P.JS || $P.ASYNC) {*/\n        var inlinePreprocessorBlock = isInline ? '/*if (' + optionName + ') {*/' : 'if (' + optionName + ') {',\n            bracesCounter = 0,\n\n            startIndex = lmd_js.indexOf(inlinePreprocessorBlock),\n            startLength = inlinePreprocessorBlock.length,\n\n            endIndex = startIndex + inlinePreprocessorBlock.length,\n            endLength = isInline ? 5 : 1;\n\n        if (startIndex === -1) {\n            return false;\n        }\n\n        // lookup for own }\n        while (lmd_js.length > endIndex) {\n            if (lmd_js[endIndex] === '{') {\n                bracesCounter++;\n            }\n            if (lmd_js[endIndex] === '}') {\n                bracesCounter--;\n            }\n            \n            // found!\n            if (bracesCounter === -1) {\n                if (isInline) {\n                    // step back\n                    endIndex -= 2;\n                } else {\n                    // remove leading spaces from open part\n                    while (startIndex) {\n                        startIndex--;\n                        startLength++;\n                        if (lmd_js[startIndex] !== '\\t' && lmd_js[startIndex] !== ' ') {\n                            startIndex++;\n                            startLength--;\n                            break;\n                        }\n                    }\n\n                    // remove leading spaces from close part\n                    while (endIndex) {\n                        endIndex--;\n                        endLength++;\n                        if (lmd_js[endIndex] !== '\\t' && lmd_js[endIndex] !== ' ') {\n                            endIndex++;\n                            endLength--;\n                            break;\n                        }\n                    }\n                    // add front \\n\n                    endLength++;\n                    startLength++;\n                }\n\n                if (isApply) {\n                    // wipe preprocessor blocks only\n                    // open\n                    lmd_js = lmd_js.substr(0, startIndex) + lmd_js.substr(startIndex + startLength);\n\n                    // close\n                    lmd_js = lmd_js.substr(0, endIndex - startLength) + lmd_js.substr(endIndex + endLength - startLength);\n\n                    if (!isInline) {\n                        // indent block back\n                        var blockForIndent = lmd_js.substr(startIndex, endIndex - startLength - startIndex);\n\n                        blockForIndent = blockForIndent\n                            .split('\\n')\n                            .map(function (line) {\n                                return line.replace(/^\\s{4}/, '');\n                            })\n                            .join('\\n');\n\n                        lmd_js = lmd_js.substr(0, startIndex) + blockForIndent + lmd_js.substr(endIndex - startLength);\n                    }\n                } else {\n                    // wipe all\n                    lmd_js = lmd_js.substr(0, startIndex) + lmd_js.substr(endIndex + endLength);\n                }\n                break;\n            }\n            endIndex++;\n        }\n\n        return true;\n    };\n\n    // Add plugins\n    var pluginsRequireList = {},\n        pluginsCode = '';\n\n    // Collect plugins code\n    for (flagName in this.flagToOptionNameMap) {\n        var plugins = this.flagToOptionNameMap[flagName].require;\n\n        if (typeof plugins !== \"undefined\") {\n            if (typeof plugins === \"string\") {\n                plugins = [plugins];\n            }\n\n            plugins.forEach(function (pluginName) {\n                // require once\n                if (config[flagName] && !pluginsRequireList[pluginName]) {\n                    pluginsCode += fs.readFileSync(path.join(LMD_JS_SRC_PATH, 'plugin', pluginName), 'utf8') + \"\\n\\n\";\n                    pluginsRequireList[pluginName] = true;\n                }\n            });\n        }\n    }\n    // Collect user plugins\n    var userPlugin;\n    for (var userPluginName in config.plugins) {\n        userPlugin = config.plugins[userPluginName];\n        if (userPlugin.isOk) {\n            pluginsCode += userPlugin.code + \"\\n\\n\";\n        }\n    }\n\n    // Apply plugins code\n    lmd_js = lmd_js.replace(\"/*{{LMD_PLUGINS_LOCATION}}*/\", pluginsCode);\n\n    // Add includes\n    for (flagName in this.flagToOptionNameMap) {\n        optionNames = this.flagToOptionNameMap[flagName].preprocess || [];\n\n        optionNames.forEach(function (optionName) {\n            /*if ($P.STATS) include('stats.js');*/\n            var includePattern = new RegExp('\\\\/\\\\*\\\\if \\\\(' + optionName.replace(/\\$/g, '\\\\$').replace(/\\|/g, '\\\\|') + '\\\\)\\\\s+include\\\\(\\'([a-z-\\\\/_\\\\.]+)\\'\\\\);?\\\\s*\\\\*\\\\/', ''),\n                patchContent = '',\n                match;\n\n            // Add plugin\n            while (true) {\n                if (config[flagName]) {\n                    // apply: remove left & right side\n\n                    match = lmd_js.match(includePattern);\n                    if (match && match[1]) {\n                        patchContent = fs.readFileSync(path.join(LMD_JS_SRC_PATH, 'plugin', match[1]), 'utf8');\n                    } else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n                lmd_js = lmd_js.replace(includePattern, patchContent);\n            }\n        });\n    }\n\n    // Apply IF statements\n    for (flagName in this.flagToOptionNameMap) {\n        optionNames = this.flagToOptionNameMap[flagName].preprocess || [];\n\n        // first are inline\n        optionNames.forEach(function (optionName) {\n            // apply all blocks\n            if (config[flagName]) {\n                // 1. inline\n                while (preProcessBlock(optionName, true, true));\n                // 2. blocks\n                while (preProcessBlock(optionName, true, false));\n            }\n        });\n    }\n\n    // Wipe IF statements\n    for (flagName in this.flagToOptionNameMap) {\n        optionNames = this.flagToOptionNameMap[flagName].preprocess || [];\n\n        // first are inline\n        optionNames.forEach(function (optionName) {\n            // wipe all blocks\n            if (!config[flagName]) {\n                // 1. inline\n                while (preProcessBlock(optionName, false, true));\n                // 2. blocks\n                while (preProcessBlock(optionName, false, false));\n            }\n        });\n    }\n\n    return lmd_js;\n};\n\n/**\n * Performs configuration\n */\nLmdBuilder.prototype.configure = function () {\n    if (!this.configFile) {\n        this.log.write('lmd usage:\\n\\t    lmd config.lmd.js(on) [output.lmd.js]\\n');\n        return false;\n    }\n    return true;\n};\n\n/**\n * Collecting sandboxed modules using merged config\n *\n * @param modulesStruct\n *\n * @returns {Array}\n */\nLmdBuilder.prototype.getSandboxedModules = function (modulesStruct, config) {\n    // TODO(azproduction) Backward capability\n    var result = config.sandbox || {};\n    for (var moduleName in modulesStruct) {\n        if (modulesStruct[moduleName].is_sandbox) {\n            result[moduleName] = true;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Watch the module files, rebuilding when a change is detected\n */\nLmdBuilder.prototype.fsWatch = function (config) {\n    var self = this;\n\n    for (var i = 0, c = config.errors.length; i < c; i++) {\n        this.warn(config.errors[i], config.warn);\n    }\n\n    var log = function (test) {\n            self.log.write(test);\n        },\n        rebuild = function (stat, filename) {\n            if (stat && filename) {\n                log('info'.green + ':    Change detected in ' + path.basename(filename).toString().green + ' at ' + stat.mtime.toString().blue);\n            } else if (stat) {\n                log('info'.green + ':    Change detected at ' + stat.mtime.toString().blue);\n            } else {\n                log('info'.green + ':   ');\n            }\n\n            log(' Rebuilding...\\n');\n\n            var buildResult = new LmdBuilder(self.configFile, self.options);\n\n            new Writer(buildResult)\n                .writeAll(function (err) {\n                    if (!buildResult.buildConfig.output) {\n                        return;\n                    }\n                    if (err) {\n                        log('info'.red + ':    Build failed'.red + '\\n');\n                    } else {\n                        log('info'.green + ':    Build complete'.green + '\\n');\n                    }\n                });\n\n        },\n        watch = function (event, filename) {\n            if (event === 'change') {\n                if (filename) {\n                    rebuild(fs.stat(filename), filename);\n                } else {\n                    rebuild();\n                }\n            }\n        },\n        watchFile = function (curr, prev, filename) {\n            if (curr.mtime > prev.mtime) {\n                rebuild(curr, filename);\n            }\n        },\n        addWatcherFor = function (modulePath) {\n            try {\n                // a mess....\n                fs.watchFile(modulePath, { interval: 1000 }, function (curr, prev) {\n                    watchFile(curr, prev, modulePath);\n                });\n            } catch (e) {\n                fs.watch(modulePath, watch);\n            }\n        },\n        collectModuleNames = function (config) {\n            var names = [],\n                module,\n                bundle,\n                modules = config.modules,\n                styles = config.styles,\n                bundles = config.bundles;\n\n            // Collect modules\n            for (var moduleName in modules) {\n                module = modules[moduleName];\n\n                if (Array.isArray(module.path)) {\n                    names = names.concat(module.path);\n                } else {\n                    // Skip shortcuts\n                    if (module.path.charAt(0) === '@') continue;\n                    names.push(module.path);\n                }\n            }\n\n            for (var i = 0, c = styles.length; i < c; i++) {\n                names.push(styles[i].path);\n            }\n\n            // Collect modules from bundles\n            for (var bundleName in bundles) {\n                bundle = bundles[bundleName];\n\n                if (!(bundle instanceof Error)) {\n                    collectModuleNames(bundle).forEach(function (moduleName) {\n                        // uniq only\n                        if (names.indexOf(moduleName) === -1) {\n                            names.push(moduleName);\n                        }\n                    });\n                }\n            }\n\n            return names;\n        };\n\n    var modules = collectModuleNames(config),\n        watchedModulesCount = modules.length;\n\n    // is there any modules?\n    if (watchedModulesCount) {\n        // add all modules\n        modules.forEach(function (modulePath) {\n            addWatcherFor(modulePath);\n        });\n\n        // add lmd.json too\n        addWatcherFor(this.configFile);\n        log('info'.green + ':    Now watching ' + watchedModulesCount.toString().green + ' files. Ctrl+C to stop\\n');\n\n        // Rebuild at startup\n        rebuild();\n    }\n};\n\n/**\n * Formats log message\n *\n * @param text\n * @return {*}\n */\nLmdBuilder.prototype.formatLog = function (text) {\n    return text.replace(/\\*\\*([^\\*]*)\\*\\*/g, function (str) {\n        return str.replace(/^\\*\\*|\\*\\*$/g, '').green;\n    });\n};\n\n/**\n * text\\ntext + info: -> info:    text\n *                    -> info:    text\n *\n * @param {String} padding\n * @param {String} text\n * @return {String}\n */\nLmdBuilder.prototype.addPaddingToText = function (padding, text) {\n    return text.split('\\n').map(function (line) {\n        return padding + ':    ' + line;\n    }).join('\\n') + '\\n';\n};\n\n/**\n * Formats and prints an error\n *\n * @param {String} text simple markdown syntax\n *\n * @example\n *     Pewpew **ololo** - ololo will be green\n */\nLmdBuilder.prototype.error = function (text) {\n    text = this.formatLog(text);\n    this.log.write(this.addPaddingToText('ERRO'.red.inverse, text));\n};\n\n/**\n * Formats and prints an warning\n *\n * @param {String} text simple markdown syntax\n *\n * @example\n *     Pewpew **ololo** - ololo will be green\n */\nLmdBuilder.prototype.warn = function (text, isWarn) {\n    if (isWarn) {\n        text = this.formatLog(text);\n        this.log.write(this.addPaddingToText('warn'.yellow, text));\n    }\n};\n\n/**\n * Formats and prints an info\n *\n * @param {String} text simple markdown syntax\n *\n * @example\n *     Pewpew **ololo** - ololo will be green\n */\nLmdBuilder.prototype.info = function (text) {\n    text = this.formatLog(text);\n    this.log.write(this.addPaddingToText('info'.green, text));\n};\n\n/**\n * Generates module token\n *\n * @param {String} modulePath\n */\nLmdBuilder.prototype.createToken = function (modulePath) {\n    // issue 178 String modules getting corrupted on Windows when using source map.\n    // replace \\ with / in order to fix JSON.stringify escaping issue\n    modulePath = modulePath.replace(/\\\\/g, '/');\n    return '/**[[LMD_TOKEN]]:' + modulePath + '**/';\n};\n\n/**\n * Calculates module offset relative to source file\n *\n * @param {String} source     result source with tokens\n * @param {Number} tokenIndex module offset\n *\n * @return {Object} {column, line}\n */\nLmdBuilder.prototype.getModuleOffset = function (source, tokenIndex) {\n    var cols = 0,\n        rows = 1;\n\n    for (var i = 0, symbol; i < tokenIndex; i++) {\n        symbol = source[i];\n\n        if (symbol === '\\n') {\n            rows++;\n            cols = 0;\n        } else {\n            cols++;\n        }\n    }\n\n    return {\n        column: cols,\n        line: rows\n    };\n};\n\n/**\n * Generates source map, removes source map tokens\n *\n * @param {Object}  modules          in package modules\n * @param {Object}  modulesInfo      information about package modules\n * @param {String}  sourceWithTokens source with sourcemap tokens\n * @param {String}  config           module config\n *\n * @return {Object} {source: cleanSource, sourceMap: sourceMap}\n */\nLmdBuilder.prototype.createSourceMap = function (modules, modulesInfo, sourceWithTokens, config) {\n    var configRoot = String(config.root || config.path || ''),\n        configOutput = String(config.output || ''),\n        configWwwRoot = String(config.www_root || ''),\n        // #174 apply default value only for non-strings\n        configSourcemapWww = typeof config.sourcemap_www === 'string' ? config.sourcemap_www : '/',\n        configSourcemap = String(config.sourcemap || ''),\n        configSourceMappingURL = String(config.sourcemap_url || '');\n\n    var generatedFile = path.resolve(this.configDir, configRoot, configOutput),\n        root = path.resolve(this.configDir, configRoot, configWwwRoot),\n        sourceMapFile = path.resolve(this.configDir, configRoot, configSourcemap),\n        isInline = config.sourcemap_inline || false,\n        isWarn = config.warn;\n\n    var self = this,\n        module,\n        moduleInfo,\n        originalSourceMapDetect = /sourceMappingURL=(.*)*/,\n        hasOriginalSourceMap,\n        originalSourceMapPath,\n        originalSourceMap,\n        first,\n        sourceMapsApplied = 0,\n        sourceMapSkipped = [];\n\n    root = fs.realpathSync(root);\n\n    var sourceMap = new SourceMapGenerator({\n        file: path.relative(root, generatedFile),\n        sourceRoot: configSourcemapWww\n    });\n\n    for (var moduleName in modules) {\n        module = modules[moduleName];\n        moduleInfo = modulesInfo[moduleName];\n        if (this.isModuleCanBeUnderSourceMap(module)) {\n            var token = self.createToken(module.path),\n                tokenIndex = sourceWithTokens.indexOf(token);\n\n            if (tokenIndex === -1) {\n                continue;\n            }\n\n            var offset = self.getModuleOffset(sourceWithTokens, tokenIndex),\n                // #174 replace back slashes with front slashes\n                source = path.relative(root, module.path).replace(/\\\\/g, '/');\n\n            hasOriginalSourceMap = false;\n\n            try {\n                // detect original sourceMap in module code [sourceMappingURL=...]\n                if (originalSourceMapDetect.test(moduleInfo.code)) {\n                    originalSourceMapPath = path.resolve(path.dirname(path.relative(root, module.path)),\n                        originalSourceMapDetect.exec(moduleInfo.code)[1]);\n\n                    if (fs.existsSync(originalSourceMapPath)) {\n                        hasOriginalSourceMap = true;\n                        originalSourceMap = JSON.parse(fs.readFileSync(originalSourceMapPath));\n                    }\n                }\n                // find sourceMap in module directory\n                if (!hasOriginalSourceMap && fs.existsSync(module.path + '.map')) {\n                    hasOriginalSourceMap = true;\n                    originalSourceMap = JSON.parse(fs.readFileSync(module.path + '.map'));\n                }\n            } catch (e) {}\n\n            if (hasOriginalSourceMap) {\n                originalSourceMap = new SourceMapConsumer(originalSourceMap);\n\n                first = true;\n                // move original source map => result source map\n                originalSourceMap.eachMapping(function (mapping) {\n                    sourceMap.addMapping({\n                        generated: {\n                            // only first line can be with column offset\n                            column: (first ? offset.column : 0) +  mapping.generatedColumn,\n                            line: offset.line - 1 + mapping.generatedLine\n                        },\n                        original: {\n                            column: mapping.originalColumn,\n                            line: mapping.originalLine\n                        },\n                        source: mapping.source\n                    });\n                    first = false;\n                });\n            } else {\n                // add mapping for each line\n                for (var i = 0; i < module.lines; i++) {\n                    sourceMap.addMapping({\n                        generated: {\n                            // only first line can be with column offset\n                            column: i ? 0 : offset.column,\n                            line: offset.line + i\n                        },\n                        original: {\n                            column: 0,\n                            line: i + 1\n                        },\n                        source: source\n                    });\n                }\n            }\n\n            // remove token\n            sourceWithTokens = sourceWithTokens.replace(token, '');\n            sourceMapsApplied++;\n        } else {\n            if (!module.is_shortcut) {\n                sourceMapSkipped.push(moduleName);\n            }\n        }\n    }\n\n    if (sourceMapsApplied === 0) {\n        this.warn('There is no modules under Source Map!', isWarn);\n    } else if (sourceMapSkipped.length) {\n        this.warn('Source Map is not applied for these modules: **' + sourceMapSkipped.join('**, **') + '**', isWarn);\n    }\n\n    configSourceMappingURL = configSourceMappingURL || '/' + path.relative(root, sourceMapFile) + '?' + Math.random();\n\n    if (isInline && sourceMapsApplied !== 0) {\n        // append helper\n        sourceWithTokens += '\\n\\n//@ sourceMappingURL=' + configSourceMappingURL + '\\n';\n    }\n\n    return {\n        source: sourceWithTokens,\n        sourceMap: sourceMap\n    };\n};\n\n/**\n *\n * @param {String} source\n *\n * @return {Number}\n */\nLmdBuilder.prototype.calculateModuleLines = function (source) {\n    var lines = 1;\n    for (var i = 0, c = source.length; i < c; i++) {\n         if (source[i] === \"\\n\") {\n            lines++;\n         }\n    }\n\n    return lines;\n};\n\n/**\n *\n * @param {Object} moduleDescriptor\n *\n * @return {Boolean}\n */\nLmdBuilder.prototype.isModuleCanBeUnderSourceMap = function (moduleDescriptor) {\n    return !moduleDescriptor.is_shortcut &&\n           !moduleDescriptor.is_coverage &&\n           !moduleDescriptor.is_lazy &&\n           !moduleDescriptor.is_multi_path_module;\n};\n\nLmdBuilder.prototype.applySourceMap = function (module, moduleInfo) {\n    if (this.isModuleCanBeUnderSourceMap(module)) {\n        var originalCodeWithToken = this.createToken(module.path) + moduleInfo.originalCode;\n        // reapply wrapper\n        moduleInfo.code = common.wrapModule(originalCodeWithToken, module, moduleInfo.type);\n        module.lines = this.calculateModuleLines(moduleInfo.code);\n    }\n};\n\n/**\n * Format one module\n *\n * @param moduleInfo\n *\n * @return {*}\n */\nLmdBuilder.prototype.formatModule = function (module, moduleInfo, modulesBundle, config, isPack) {\n    var mainModuleName = config.main;\n\n    switch (moduleInfo.type) {\n        case \"amd\":\n        case \"fd\":\n        case \"fe\":\n        case \"plain\":\n        case \"3-party\":\n            // #26 Code coverage\n            if (module.is_coverage) {\n                var skipLines = ({\n                    fd: 1,\n                    fe: 1,\n                    plain: 0,\n                    amd: -1\n                })[moduleInfo.type];\n\n                var coverageResult = lmdCoverage.interpret(module.name, module.path, moduleInfo.code, skipLines);\n                modulesBundle.options[module.name] = coverageResult.options;\n                modulesBundle.options[module.name].coverage = 1;\n                moduleInfo.code = coverageResult.code;\n            }\n\n            if (module.is_lazy || isPack) {\n                moduleInfo.code = this.compress(moduleInfo.code, config.pack_options);\n            }\n\n            if (module.name !== mainModuleName && module.is_lazy) {\n                moduleInfo.code = moduleInfo.code.replace(/^function[^\\(]*/, 'function');\n                if (moduleInfo.code.indexOf('(function(') !== 0) {\n                    moduleInfo.code = '(' + moduleInfo.code + ')';\n                }\n                moduleInfo.code = this.escape(moduleInfo.code);\n            }\n            break;\n        case \"string\":\n            moduleInfo.code = this.escape(moduleInfo.code);\n            break;\n    }\n};\n\n/**\n * Format Modules\n *\n * @param config\n *\n * @returns {Object} {main: 'string', modules: ['\"name\": moduleContent'], options: {\"name\": {}}}\n */\nLmdBuilder.prototype.formatModules = function (modules, modulesInfo, config, isPack) {\n    var self = this;\n    var modulesBundle = {\n        main: '',\n        modules: [],\n        options: {}\n    };\n\n    if (!config.modules) {\n        return modulesBundle;\n    }\n\n    var mainModuleName = config.main;\n\n    // build modules string\n    for (var index in modules) {\n        var module = modules[index],\n            moduleInfo = modulesInfo[index];\n\n        // pipe warnings to errors\n        moduleInfo.warns.forEach(function (warning) {\n            self.warn(warning, config.warn);\n        });\n\n        if (moduleInfo.type === \"shortcut\") {\n            if (module.name === mainModuleName) {\n                this.warn('Main module can not be a shortcut. Your app will throw an error.', config.warn);\n            } else {\n                modulesBundle.modules.push(this.escape(module.name) + ': ' + this.escape(module.path));\n            }\n            continue;\n        }\n\n        if (config.sourcemap) {\n            this.applySourceMap(module, moduleInfo);\n        }\n        this.formatModule(module, moduleInfo, modulesBundle, config, isPack);\n\n        if (module.name === mainModuleName) {\n            modulesBundle.main = moduleInfo.code;\n        } else {\n            modulesBundle.modules.push(this.escape(module.name) + ': ' + moduleInfo.code);\n        }\n    }\n\n    var sandboxedModules = this.getSandboxedModules(modules, config);\n    for (var moduleName in sandboxedModules) {\n        if (!modulesBundle.options[moduleName]) {\n            modulesBundle.options[moduleName] = {};\n        }\n        modulesBundle.options[moduleName].sandbox = 1;\n    }\n\n    return modulesBundle;\n};\n\nLmdBuilder.prototype._build = function (config, isBundle) {\n    isBundle = isBundle || false;\n\n    var self = this,\n        lazy = config.lazy || false,\n        cache = config.cache || false,\n        pack = (lazy || cache) ? true : (config.pack || false),\n        isOptimizeLmd = pack || config.optimize || false;\n\n    var result;\n\n    if (config.modules) {\n        var modules = config.modules,\n            modulesInfo = common.collectModulesInfo(config);\n\n        if (config.warn) {\n            common.collectFlagsWarnings(config, modulesInfo).forEach(function (warning) {\n                self.warn(warning, config.warn);\n            });\n        }\n\n        common.collectFlagsNotifications(config).forEach(function (notification) {\n            self.info(notification);\n        });\n\n        var modulesBundle = this.formatModules(modules, modulesInfo[common.ROOT_BUNDLE_ID], config, pack),\n            sourceMap = '',\n            lmdFile;\n\n        if (isBundle) {\n            lmdFile = this.renderLmdBundle(config, modulesBundle);\n        } else {\n            lmdFile = this.renderLmdPackage(config, modulesBundle, isOptimizeLmd);\n        }\n\n        if (config.sourcemap) {\n            var sourceMapResult = this.createSourceMap(modules, modulesInfo[common.ROOT_BUNDLE_ID], lmdFile, config);\n\n            lmdFile = sourceMapResult.source;\n            sourceMap = sourceMapResult.sourceMap;\n        }\n\n        if (pack) {\n            // TODO(azproduction) Add sourceMap to it\n            lmdFile = this.compress(lmdFile, config.pack_options);\n        }\n\n        result = result || {};\n        result.source = lmdFile;\n        result.sourceMap =  sourceMap;\n    }\n\n    if (config.styles) {\n        var style = this.renderStyles(config.styles, isOptimizeLmd);\n        result = result || {};\n        result.style = style;\n    }\n\n    if (config.bundles) {\n        var bundles = config.bundles;\n        for (var bundleName in bundles) {\n            bundles[bundleName] = this._build(bundles[bundleName], true);\n        }\n\n        result = result || {};\n        result.bundles = bundles;\n    }\n\n    return result;\n};\n\nLmdBuilder.prototype._has = function (config, what) {\n    return !!(config && config[what] && Object.keys(config[what]).length);\n};\n\nLmdBuilder.prototype._initBundlesStreams = function (bundles) {\n    var self = this;\n\n    Object.keys(bundles).forEach(function (bundleName) {\n        var stream = new DataStream();\n        stream.readable = self._has(bundles[bundleName], 'modules');\n\n        self.bundles[bundleName] = stream;\n\n        stream.sourceMap = new DataStream();\n        stream.sourceMap.readable = self._has(bundles[bundleName], 'modules');\n\n        stream.style = new DataStream();\n        stream.style.readable = self._has(bundles[bundleName], 'styles');\n    });\n};\n\n/**\n *\n * @param bundles\n * @return {*}\n * @private\n */\nLmdBuilder.prototype._streamBundles = function (bundles) {\n    var self = this;\n\n    Object.keys(bundles).forEach(function (bundleName) {\n        var bundle = bundles[bundleName],\n            stream = self.bundles[bundleName];\n\n        stream.write(bundle.source);\n        stream.style.write(bundle.style);\n        stream.sourceMap.write(bundle.sourceMap.toString());\n    });\n};\n\n/**\n * @private\n */\nLmdBuilder.prototype._closeBundleStreams = function () {\n    var self = this;\n\n    if (!self.bundles) {\n        return;\n    }\n\n    Object.keys(self.bundles).forEach(function (bundleName) {\n        var stream = self.bundles[bundleName];\n        stream.end();\n        stream.style.end();\n        stream.sourceMap.end();\n    });\n};\n\n/**\n * Main builder\n *\n * @returns {Object} {source: cleanSource, sourceMap: sourceMap}\n */\nLmdBuilder.prototype.build = function (config) {\n    // TODO TEST BUNDLES!!!!\n    for (var i = 0, c = config.errors.length; i < c; i++) {\n        this.warn(config.errors[i], config.warn);\n    }\n\n    if (typeof config.ie === \"undefined\") {\n        config.ie = true;\n    }\n\n    if (!config.cache && config.cache_async) {\n        this.warn('This package was configured with flag **cache_async: true**, but without flag **cache**; ' +\n            'cache_async cant work independently. Flag cache_async is disabled! Please switch on **cache**.', config.warn);\n        config.cache_async = false;\n    }\n\n    if (config.cache && typeof config.version === \"undefined\") {\n        this.warn('This package was configured with flag **cache: true**, but without flag **version** parameter. ' +\n            'Please define **version** to enable cache.', config.warn);\n    }\n\n    return this._build(config);\n};\n\nmodule.exports = LmdBuilder;\nmodule.exports.Writer = Writer;\nmodule.exports.Cli = Cli;\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/lib/data_stream.js":"var Duplex = require('readable-stream').Duplex,\n    inherits = require('util').inherits;\n\nfunction DataStream() {\n    Duplex.call(this);\n    this._finished = false;\n    this._receiverCapacity = 0;\n    this._buffer = new Buffer(0);\n}\ninherits(DataStream, Duplex);\n\nDataStream.prototype._write = function (chunk, encoding, callback) {\n    this._buffer = Buffer.concat([this._buffer, new Buffer(chunk, encoding)]);\n    this._push();\n    callback();\n};\n\nDataStream.prototype._push = function () {\n    // ALL written & flushed\n    if (this._finished && this._buffer.length === 0) {\n        this.push(null);\n        return;\n    }\n\n    // Nothing to read or ca not write\n    if (!this._receiverCapacity || !this._buffer.length) {\n        return;\n    }\n\n    var chunkSize = this._receiverCapacity > this._buffer.length ? this._buffer.length : this._receiverCapacity;\n    var chunk = this._buffer.slice(0, chunkSize);\n    this._receiverCapacity -= chunk.length;\n\n    this._buffer = this._buffer.slice(chunk.length);\n    this.push(chunk);\n};\n\nDataStream.prototype._read = function (size) {\n    this._receiverCapacity += size;\n    this._push();\n};\n\nDataStream.prototype.end = function () {\n    Duplex.prototype.end.apply(this, arguments);\n    this._finished = true;\n    this._push();\n};\n\nmodule.exports = DataStream;\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/lib/coverage_apply.js":"/**\n * This code was originally made by Fabio Crisci and distributed under MIT licence\n *\n * Copyright (c) 2012 Fabio Crisci <fabio.crisci@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nvar parser = require(\"uglify-js\").parser;\nvar uglify = require(\"uglify-js\").uglify;\n\nfunction generateCode (tree) {\n\treturn uglify.gen_code(tree, {beautify : true});\n};\n\n/**\n * This is the main function of this module (it's the only one exported)\n * Given a file path and content returns the instrumented file\n * It won't instrument files that are already instrumented\n *\n * options allow to enable/disable coverage metrics\n *    \"function\" enable function coverage\n *    \"condition\" enable condition coverage\n */\nexports.interpret = function (moduleName, file, content, lineOffset, options) {\n\toptions = options || {\n\t\t\"function\" : true,\n\t\t\"condition\" : true\n\t};\n\n\ttry {\n\t\tvar tree = parser.parse(content, false, true);\n\t} catch (e) {\n\t\treturn {\n            error: \"Error instrumentig file \" + file + \" \" + e.message\n        }\n\t}\n\n\tvar walker = uglify.ast_walker();\n\t// this is the list of nodes being analyzed by the walker\n\t// without this, w.walk(this) would re-enter the newly generated code with infinite recursion\n\tvar analyzing = [];\n\t// list of all lines' id encounterd in this file\n\tvar lines = [];\n\t// list of all conditions' id encounterd in this file\n\tvar allConditions = [];\n\t// list of all functions' id encounterd in this file\n\tvar allFunctions = [];\n\t// anonymous function takes the name of their var definition\n\tvar candidateFunctionName = null;\n\n    var isFirstFunction = true,\n        isFirstLine = true;\n\n\t/**\n\t * A statement was found in the file, remember its id.\n\t */\n\tfunction rememberStatement (id) {\n\t\tlines.push(id);\n\t};\n\n\t/**\n\t * A function was found in the file, remember its id.\n\t */\n\tfunction rememberFunction (id) {\n\t\tallFunctions.push(id);\n\t};\n\n\t/**\n\t * Generic function for counting a line.\n\t * It generates a lineId from the line number and the block name (in minified files there\n\t * are more logical lines on the same file line) and adds a function call before the actual\n\t * line of code.\n\t *\n\t * 'this' is any node in the AST\n\t */\n\tfunction countLine() {\n\t\tvar ret;\n        // skip first line\n        if (isFirstLine) {\n            isFirstLine = false;\n            return ret;\n        }\n\t\tif (this[0].start && analyzing.indexOf(this) < 0) {\n\t\t\tgiveNameToAnonymousFunction.call(this);\n\t\t\tvar lineId = this[0].start.line + lineOffset + ''; //this[0].name + ':' + this[0].start.line + \":\" + this[0].start.pos;\n\t\t\trememberStatement(lineId);\n\n\t\t\tanalyzing.push(this);\n\t\t\tret = [ \"splice\",\n\t\t\t\t[\n\t\t\t\t\t[ \"stat\",\n\t\t\t\t\t\t[ \"call\",\n                            [\"dot\", [\"name\", \"require\"], \"coverage_line\"],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t[ \"string\", moduleName],\n\t\t\t\t\t\t\t\t[ \"string\", lineId]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t],\n\t\t\t\t\twalker.walk(this)\n\t\t\t\t]\n\t\t\t];\n\t\t\tanalyzing.pop(this);\n\t\t}\n\t\treturn ret;\n\t};\n\n\t/**\n\t * Walker for 'if' nodes. It overrides countLine because we want to instrument conditions.\n\t *\n\t * 'this' is an if node, so\n\t *    'this[0]' is the node descriptor\n\t *    'this[1]' is the decision block\n\t *    'this[2]' is the 'then' code block\n\t *    'this[3]' is the 'else' code block\n\t *\n\t * Note that if/else if/else in AST are represented as nested if/else\n\t */\n\tfunction countIf() {\n\t\tvar self = this, ret;\n\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\tvar decision = self[1];\n\t\t\tvar lineId = self[0].name + ':' + (self[0].start.line + lineOffset);\n\n\t\t\tself[1] = wrapCondition(decision, lineId);\n\n\t\t\t// We are adding new lines, make sure code blocks are actual blocks\n\t\t\tif (self[2] && self[2][0].start && self[2][0].start.value != \"{\") {\n\t\t\t\tself[2] = [ \"block\", [self[2]]];\n\t\t\t}\n\n\t\t\tif (self[3] && self[3][0].start && self[3][0].start.value != \"{\") {\n\t\t\t\tself[3] = [ \"block\", [self[3]]];\n\t\t\t}\n\t\t}\n\n\t\tret = countLine.call(self);\n\n\t\tif (decision) {\n\t\t\tanalyzing.pop(decision);\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\t/**\n\t * This is the key function for condition coverage as it wraps every condition in\n\t * a function call.\n\t * The condition id is generated fron the lineId (@see countLine) plus the character\n\t * position of the condition.\n\t */\n\tfunction wrapCondition(decision, lineId, parentPos) {\n\t\tif (options.condition === false) {\n\t\t\t// condition coverage is disabled\n\t\t\treturn decision;\n\t\t}\n\n\t\tif (isSingleCondition(decision)) {\n\t\t\tvar pos = getPositionStart(decision, parentPos);\n\t\t\tvar condId = lineId + \":\" + pos;\n\n\t\t\tanalyzing.push(decision);\n\t\t\tallConditions.push(condId);\n\t\t\treturn [\"call\",\n                [\"dot\", [\"name\", \"require\"], \"coverage_condition\"],\n\t\t\t\t[\n\t\t\t\t\t[ \"string\", moduleName ],\n\t\t\t\t\t[ \"string\", condId],\n\t\t\t\t\tdecision\n\t\t\t\t]\n\t\t\t];\n\t\t} else {\n\t\t\tdecision[2] = wrapCondition(decision[2], lineId, getPositionStart(decision, parentPos));\n\t\t\tdecision[3] = wrapCondition(decision[3], lineId, getPositionEnd(decision, parentPos));\n\n\t\t\treturn decision;\n\t\t}\n\t};\n\n\t/**\n\t * Wheter or not the if decision has only one boolean condition\n\t */\n\tfunction isSingleCondition(decision) {\n\t\tif (decision[0].start && decision[0].name != \"binary\") {\n\t\t\treturn true;\n\t\t} else if (decision[1] == \"&&\" || decision[1] == \"||\") {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * Get the start position of a given condition, if it has a start it's a true condition\n\t * so get the value, otherwise use a default value that is coming from an upper decision\n\t */\n\tfunction getPositionStart (decision, defaultValue) {\n\t\tif (decision[0].start) {\n\t\t\treturn decision[0].start.pos;\n\t\t} else {\n\t\t\treturn defaultValue || \"s\";\n\t\t}\n\t};\n\n\t/**\n\t * As for getPositionStart but returns end position. It allows to give different ids to\n\t * math and binary operations in multiple conditions ifs.\n\t */\n\tfunction getPositionEnd (decision, defaultValue) {\n\t\tif (decision[0].end) {\n\t\t\treturn decision[0].end.pos;\n\t\t} else {\n\t\t\treturn defaultValue || \"e\";\n\t\t}\n\t};\n\n\t/**\n\t * Generic function for every node that needs to be wrapped in a block.\n\t * For instance, the following code\n\t *\n\t *    for (a in b) doSomething(a)\n\t *\n\t * once converted in AST does not have a block but only a function call.\n\t * Instrumentig this code would return\n\t *\n\t *    for (a in b) instrumentation()\n\t *    doSomething(a)\n\t *\n\t * which clearly does not have the same behavior as the non instrumented code.\n\t *\n\t * This function generates a function that can be used by the walker to add\n\t * blocks when they are missing depending on where the block is supposed to be\n\t */\n\tfunction wrapBlock(position) {\n\t\treturn function countFor() {\n\t\t\tvar self = this;\n\n\t\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\t\t\tif (self[position] && self[position][0].name != \"block\") {\n\t\t\t\t\t\tself[position] = [ \"block\", [self[position]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn countLine.call(self);\n\t\t};\n\t};\n\n\t/**\n\t * Label nodes need special treatment as well.\n\t *\n\t *    myLabel : for (;;) {\n\t *\t     //whateveer code here\n\t *       continue myLabel\n\t *    }\n\t *\n\t * Label can be wrapped by countLine, hovewer the subsequent for shouldn't be wrapped.\n\t *\n\t *    instrumentation(\"label\");\n\t *    mylabel : instrumentation(\"for\")\n\t *       for (;;) {}\n\t *\n\t * The above code would be wrong.\n\t *\n\t * This function makes sure that the 'for' after a label is not instrumented and that\n\t * the 'for' content is wrapped in a block.\n\t *\n\t * I'm don't think it's reasonable to use labels with something that is not a 'for' block.\n\t * In that case the instrumented code might easily break.\n\t */\n\tfunction countLabel() {\n\t\tvar ret;\n\t\tif (this[0].start && analyzing.indexOf(this) < 0) {\n\t\t\tvar content = this[2];\n\n\t\t\tif (content[0].name == \"for\" && content[4] && content[4].name != \"block\") {\n\t\t\t\tcontent[4] = [ \"block\", [content[4]]];\n\t\t\t}\n\t\t\tanalyzing.push(content);\n\n\t\t\tvar ret = countLine.call(this);\n\n\t\t\tanalyzing.pop(content);\n\t\t}\n\t\treturn ret;\n\t};\n\n\t/**\n\t * Instrumenting function strictly needed for statement coverage only in case of 'defun'\n\t * (function definition), however the block 'function' does not correspond to a new statement.\n\t * This method allows to track every function call (function coverage).\n\t *\n\t * As far as I can tell, 'function' is different from 'defun' for the fact that 'defun'\n\t * refers to the global definition of a function\n\t *    function something () {}    -> defun\n\t *    something = function () {}  -> function\n\t * 'function' doesn't need to be counted because the line is covered by 'name' or whatever\n\t * other block.\n\t *\n\t * Strictly speaking full statement coverage does not imply function coverage only if there\n\t * are empty function, which however are empty!\n\t *\n\t * The tracking for functions is also a bit different from countLine (except 'defun'). This\n\t * method assigns every function a name and tracks the history of every call throughout the\n\t * whole lifetime of the application, It's a sort of profiler.\n\t *\n\t *\n\t * The structure of 'this' is\n\t *    'this[0]' node descriptor\n\t *    'this[1]' string, name of the function or null\n\t *    'this[2]' array of arguments names (string)\n\t *    'this[3]' block with the function's body\n\t *\n\t * As 'function' happens in the middle of a line, the instrumentation should be in the body.\n\t */\n\tfunction countFunction () {\n\t\tvar ret;\n        if (isFirstLine) {\n            isFirstLine = false;\n            return ret;\n        }\n\t\tif (this[0].start && analyzing.indexOf(this) < 0) {\n\t\t\tvar defun = this[0].name === \"defun\";\n\t\t\tvar lineId = this[0].start.line + lineOffset + ''; //this[0].name + \":\" + this[0].start.line + \":\" + this[0].start.pos;\n\t\t\tvar fnName = this[1] || this[0].anonymousName || \"(?)\";\n            var fnId = fnName + ':' + (this[0].start.line + lineOffset) + \":\" + this[0].start.pos;\n\t\t\tvar body = this[3];\n\n\t\t\tanalyzing.push(this);\n\n\t\t\t// put a new function call inside the body, works also on empty functions\n\t\t\tif (options[\"function\"]) {\n\t\t\t\tbody.splice(0, 0, [ \"stat\",\n\t\t\t\t\t[ \"call\",\n                        [\"dot\", [\"name\", \"require\"], \"coverage_function\"],\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t[\"string\", moduleName],\n\t\t\t\t\t\t\t[\"string\", fnId]\n\t\t\t\t\t\t]\n\t\t\t\t\t]\n\t\t\t\t]);\n\t\t\t\t// It would be great to instrument the 'exit' from a function\n\t\t\t\t// but it means tracking all return statements, maybe in the future...\n\n\t\t\t\trememberFunction(fnId);\n\t\t\t}\n\n\t\t\tif (defun) {\n\t\t\t\t// 'defun' should also be remembered as statements\n\t\t\t\trememberStatement(lineId);\n\n\t\t\t\tret = [ \"splice\",\n\t\t\t\t\t[\n\t\t\t\t\t\t[ \"stat\",\n\t\t\t\t\t\t\t[ \"call\",\n                                [\"dot\", [\"name\", \"require\"], \"coverage_line\"],\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t[ \"string\", moduleName],\n\t\t\t\t\t\t\t\t\t[ \"string\", lineId]\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\twalker.walk(this)\n\t\t\t\t\t]\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tret = walker.walk(this);\n\t\t\t}\n\n\t\t\tanalyzing.pop(this);\n\n\t\t}\n\t\treturn ret;\n\t};\n\n\t/**\n\t * This function tries to extract the name of anonymous functions depending on where they are\n\t * defined.\n\t *\n\t * For instance\n\t *    var something = function () {}\n\t * the function itself is anonymous but we can use 'something' as its name\n\t *\n\t * 'node' is anything that gets counted, function are extracted from\n\t *\n\t * var\n\t *   node[0] : node description\n\t *   node[1] : array of assignments\n\t *       node[x][0] : variable name\n\t *       node[x][1] : value, node\n\t *\n\t * object  (when functions are properties of an object)\n\t *   node[0] : node description\n\t *   node[1] : array of attributes\n\t *       node[x][0] : attribute name\n\t *       node[x][1] : value, node\n\t *\n\t * assign  (things like object.name = function () {})\n\t *   node[0] : node description\n\t *   node[1] : type of assignment, 'true' if '=' or operand (like += |= and others)\n\t *   node[2] : left value, object property or variable\n\t *   node[3] : right value, node\n\t *\n\t *   in case of assign, node[2] can be\n\t *      'name' if we assign to a variable\n\t *          name[0] : node description\n\t *          name[1] : variable's name\n\t *      'dot' when we assign to an object's property\n\t *          dot[0] : node description\n\t *          dot[1] : container object\n\t *          dot[2] : property\n\t */\n\tfunction giveNameToAnonymousFunction () {\n\t\tvar node = this;\n\n\t\tif (node[0].name == \"var\" || node[0].name == \"object\") {\n\t\t\tnode[1].forEach(function (assignemt) {\n\t\t\t\tif (assignemt[1]) {\n\t\t\t\t\tif (assignemt[1][0].name === \"function\") {\n\t\t\t\t\t\tassignemt[1][0].anonymousName = assignemt[0];\n\t\t\t\t\t} else if (assignemt[1][0].name === \"conditional\") {\n\t\t\t\t\t\tif (assignemt[1][2][0] && assignemt[1][2][0].name === \"function\") {\n\t\t\t\t\t\t\tassignemt[1][2][0].anonymousName = assignemt[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (assignemt[1][3][0] && assignemt[1][3][0].name === \"function\") {\n\t\t\t\t\t\t\tassignemt[1][3][0].anonymousName = assignemt[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (node[0].name == \"assign\" && node[1] === true) {\n\t\t\tif (node[3][0].name === \"function\") {\n\t\t\t\tnode[3][0].anonymousName = getNameFromAssign(node);\n\t\t\t} else if (node[3][0] === \"conditional\") {\n\t\t\t\tif (node[3][2][0] && node[3][2][0].name === \"function\") {\n\t\t\t\t\tnode[3][2][0].anonymousName = getNameFromAssign(node);\n\t\t\t\t}\n\t\t\t\tif (node[3][3][0] && node[3][3][0].name === \"function\") {\n\t\t\t\t\tnode[3][3][0].anonymousName = getNameFromAssign(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction getNameFromAssign (node) {\n\t\tif (node[2][0].name === \"name\") {\n\t\t\treturn node[2][1];\n\t\t} else if (node[2][0].name === \"dot\") {\n\t\t\treturn node[2][2];\n\t\t}\n\t}\n\n\t/**\n\t * This function wraps ternary conditionals in order to have condition coverage\n\t *\n\t * 'this' is a node containing\n\t *    'this[0]' node descriptor\n\t *    'this[1]' decision block\n\t *    'this[2]' first statement\n\t *    'this[3]' second statement\n\t */\n\tfunction wrapConditionals () {\n\t\tif (options.condition === false) {\n\t\t\t// condition coverage is disabled\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this, ret;\n\t\tif (self[0].start && analyzing.indexOf(self) < 0) {\n\t\t\tanalyzing.push(self);\n\t\t\tvar lineId = self[0].name + ':' + (self[0].start.line + lineOffset);\n\n\t\t\tself[1] = wrapCondition(self[1], lineId);\n\n\t\t\tself[2] = walker.walk(self[2]);\n\t\t\tself[3] = walker.walk(self[3]);\n\n\t\t\tanalyzing.pop(self);\n\n\t\t\treturn self;\n\t\t} else if (self[1]) {\n\t\t\tself[1] = wrapCondition(self[1], lineId);\n\t\t}\n\t};\n\n    function createAstForArray(array) {\n        // [\"array\",[[\"string\",\"1\"],[\"string\",\"2\"]]]\n        var result = [];\n        for (var i = 0, c = array.length, item; i < c; i++) {\n            item = array[i];\n            result.push([\"string\", item]);\n        }\n\n        return [\"array\", result];\n    }\n\n    function insertRequireFallback() {\n        if (this[0].start) {\n            var body = this[3];\n\n            if (isFirstFunction) {\n                isFirstFunction = false;\n                // var require = arguments[0];\n                body.splice(0, 0, [\"var\",[[\"require\",[\"sub\",[\"name\",\"arguments\"],[\"num\",0]]]]]);\n            }\n        }\n    }\n\n\tvar instrumentedTree = walker.with_walkers({\n\t\t\"stat\"     : countLine,\n\t\t\"label\"    : countLabel,\n\t\t\"break\"    : countLine,\n\t\t\"continue\" : countLine,\n\t\t\"debugger\" : countLine,\n\t\t\"var\"      : countLine,\n\t\t\"const\"    : countLine,\n\t\t\"return\"   : countLine,\n\t\t\"throw\"    : countLine,\n\t\t\"try\"      : countLine,\n\t\t\"defun\"    : countFunction,\n\t\t\"if\"       : countIf,\n\t\t\"while\"    : wrapBlock(2),\n\t\t\"do\"       : wrapBlock(2),\n\t\t\"for\"      : wrapBlock(4),\n\t\t\"for-in\"   : wrapBlock(4),\n\t\t\"switch\"   : countLine,\n\t\t\"with\"     : countLine,\n\t\t\"function\" : countFunction,\n\t\t\"assign\"   : giveNameToAnonymousFunction,\n\t\t\"object\"   : giveNameToAnonymousFunction,\n\t\t\"conditional\": wrapConditionals\n\t}, function () {\n\t\treturn walker.walk(tree);\n\t});\n\n    instrumentedTree = walker.with_walkers({\n        \"function\" : insertRequireFallback\n    }, function () {\n        return walker.walk(instrumentedTree);\n    });\n\n\tvar code = generateCode(instrumentedTree);\n\treturn {\n        code: code.replace(/;$/, ''),\n        options: {\n            lines: lines,\n            conditions: allConditions,\n            functions: allFunctions\n        }\n    };\n};","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/lib/lmd_common.js":"var fs = require('fs'),\n    path = require('path'),\n    fileExists = fs.existsSync || path.existsSync,\n    uglifyCompress = require(\"uglify-js\"),\n    parser = uglifyCompress.parser,\n    uglify = uglifyCompress.uglify,\n    template = require('lodash-template'),\n    glob = require('glob'),\n    Module = require('module').Module;\n\nrequire('colors');\n\nvar DEFAULT_DEPENDS_MASK = \"*.lmd.json\";\nvar SOURCE_TWEAK_FLAGS = [\"warn\", \"log\", \"pack\", \"lazy\", \"optimize\"];\nexports.SOURCE_TWEAK_FLAGS = SOURCE_TWEAK_FLAGS;\n\nvar INHERITABLE_FIELDS = SOURCE_TWEAK_FLAGS.concat(['version', 'main', 'global', 'pack_options', 'mixins', 'bundles_callback', 'banner']);\nvar MASTER_FIELDS = INHERITABLE_FIELDS.concat(['output', 'path', 'root', \"sourcemap\", \"sourcemap_inline\", \"sourcemap_www\", \"sourcemap_url\", \"www_root\", \"name\", \"description\", 'styles_output']);\nexports.MASTER_FIELDS = MASTER_FIELDS;\n\nvar EXTRA_OPTIONS_FIELDS = MASTER_FIELDS.filter(function (field) {\n    return field !== 'mixins';\n});\n\nvar FILED_ALIASES = {\"path\": \"root\"};\n\n// Fields that will come from package into bundle.\n// There is some other fields like sourcemap_** or bundles_callback and output\nvar BUNDLE_INHERIT_FROM_PACKAGE = ['root', 'warn', 'log', 'lazy', 'pack', 'pack_options', 'optimize', 'banner'],\n    SUB_BUNDLE_SEPARATOR = '  ',\n    ROOT_BUNDLE_ID = '';\n\nvar MODULE_TYPE_HINTS = {\n    'json': 'json',\n    'string': 'string',\n    'fd': 'fd',\n    'fe': 'fe',\n    'plain': 'plain',\n    'commonjs': 'plain',\n    'cjs': 'plain',\n    '3-party': '3-party',\n    'amd': 'amd'\n};\n\nexports.SUB_BUNDLE_SEPARATOR = SUB_BUNDLE_SEPARATOR;\nexports.ROOT_BUNDLE_ID = ROOT_BUNDLE_ID;\n\nexports.GLOBALS = {\n    Array               : 1,\n    Boolean             : 1,\n    Date                : 1,\n    decodeURI           : 1,\n    decodeURIComponent  : 1,\n    encodeURI           : 1,\n    encodeURIComponent  : 1,\n    Error               : 1,\n    'eval'              : 1,\n    EvalError           : 1,\n    Function            : 1,\n    hasOwnProperty      : 1,\n    isFinite            : 1,\n    isNaN               : 1,\n    JSON                : 1,\n    Math                : 1,\n    Number              : 1,\n    Object              : 1,\n    parseInt            : 1,\n    parseFloat          : 1,\n    RangeError          : 1,\n    ReferenceError      : 1,\n    RegExp              : 1,\n    String              : 1,\n    SyntaxError         : 1,\n    TypeError           : 1,\n    URIError            : 1,\n\tArrayBuffer          : 1,\n\tArrayBufferView      : 1,\n\tAudio                : 1,\n\tBlob                 : 1,\n\taddEventListener     : 1,\n\tapplicationCache     : 1,\n\tatob                 : 1,\n\tblur                 : 1,\n\tbtoa                 : 1,\n\tclearInterval        : 1,\n\tclearTimeout         : 1,\n\tclose                : 1,\n\tclosed               : 1,\n\tDataView             : 1,\n\tDOMParser            : 1,\n\tdefaultStatus        : 1,\n\tdocument             : 1,\n\tElement              : 1,\n\tevent                : 1,\n\tFileReader           : 1,\n\tFloat32Array         : 1,\n\tFloat64Array         : 1,\n\tFormData             : 1,\n\tfocus                : 1,\n\tframes               : 1,\n\tgetComputedStyle     : 1,\n\tHTMLElement          : 1,\n\tHTMLAnchorElement    : 1,\n\tHTMLBaseElement      : 1,\n\tHTMLBlockquoteElement: 1,\n\tHTMLBodyElement      : 1,\n\tHTMLBRElement        : 1,\n\tHTMLButtonElement    : 1,\n\tHTMLCanvasElement    : 1,\n\tHTMLDirectoryElement : 1,\n\tHTMLDivElement       : 1,\n\tHTMLDListElement     : 1,\n\tHTMLFieldSetElement  : 1,\n\tHTMLFontElement      : 1,\n\tHTMLFormElement      : 1,\n\tHTMLFrameElement     : 1,\n\tHTMLFrameSetElement  : 1,\n\tHTMLHeadElement      : 1,\n\tHTMLHeadingElement   : 1,\n\tHTMLHRElement        : 1,\n\tHTMLHtmlElement      : 1,\n\tHTMLIFrameElement    : 1,\n\tHTMLImageElement     : 1,\n\tHTMLInputElement     : 1,\n\tHTMLIsIndexElement   : 1,\n\tHTMLLabelElement     : 1,\n\tHTMLLayerElement     : 1,\n\tHTMLLegendElement    : 1,\n\tHTMLLIElement        : 1,\n\tHTMLLinkElement      : 1,\n\tHTMLMapElement       : 1,\n\tHTMLMenuElement      : 1,\n\tHTMLMetaElement      : 1,\n\tHTMLModElement       : 1,\n\tHTMLObjectElement    : 1,\n\tHTMLOListElement     : 1,\n\tHTMLOptGroupElement  : 1,\n\tHTMLOptionElement    : 1,\n\tHTMLParagraphElement : 1,\n\tHTMLParamElement     : 1,\n\tHTMLPreElement       : 1,\n\tHTMLQuoteElement     : 1,\n\tHTMLScriptElement    : 1,\n\tHTMLSelectElement    : 1,\n\tHTMLStyleElement     : 1,\n\tHTMLTableCaptionElement: 1,\n\tHTMLTableCellElement : 1,\n\tHTMLTableColElement  : 1,\n\tHTMLTableElement     : 1,\n\tHTMLTableRowElement  : 1,\n\tHTMLTableSectionElement: 1,\n\tHTMLTextAreaElement  : 1,\n\tHTMLTitleElement     : 1,\n\tHTMLUListElement     : 1,\n\tHTMLVideoElement     : 1,\n\thistory              : 1,\n\tInt16Array           : 1,\n\tInt32Array           : 1,\n\tInt8Array            : 1,\n\tImage                : 1,\n\tlength               : 1,\n\tlocalStorage         : 1,\n\tlocation             : 1,\n\tMessageChannel       : 1,\n\tMessageEvent         : 1,\n\tMessagePort          : 1,\n\tmoveBy               : 1,\n\tmoveTo               : 1,\n\tMutationObserver     : 1,\n\tname                 : 1,\n\tNode                 : 1,\n\tNodeFilter           : 1,\n\tnavigator            : 1,\n\tonbeforeunload       : 1,\n\tonblur               : 1,\n\tonerror              : 1,\n\tonfocus              : 1,\n\tonload               : 1,\n\tonresize             : 1,\n\tonunload             : 1,\n\topen                 : 1,\n\topenDatabase         : 1,\n\topener               : 1,\n\tOption               : 1,\n\tparent               : 1,\n\tprint                : 1,\n\tremoveEventListener  : 1,\n\tresizeBy             : 1,\n\tresizeTo             : 1,\n\tscreen               : 1,\n\tscroll               : 1,\n\tscrollBy             : 1,\n\tscrollTo             : 1,\n\tsessionStorage       : 1,\n\tsetInterval          : 1,\n\tsetTimeout           : 1,\n\tSharedWorker         : 1,\n\tstatus               : 1,\n\ttop                  : 1,\n\tUint16Array          : 1,\n\tUint32Array          : 1,\n\tUint8Array           : 1,\n\tWebSocket            : 1,\n\twindow               : 1,\n\tWorker               : 1,\n\tXMLHttpRequest       : 1,\n\tXMLSerializer        : 1,\n\tXPathEvaluator       : 1,\n\tXPathException       : 1,\n\tXPathExpression      : 1,\n\tXPathNamespace       : 1,\n\tXPathNSResolver      : 1,\n\tXPathResult          : 1,\n    escape  : 1,\n   \tunescape: 1,\n\talert  : 1,\n\tconfirm: 1,\n\tconsole: 1,\n\tDebug  : 1,\n\topera  : 1,\n\tprompt : 1\n};\n\nexports.WORKER_GLOBALS = {\n\timportScripts: 1,\n\tpostMessage  : 1,\n\tself         : 1\n};\n\nexports.NODE_GLOBALS = {\n\t__filename   : 1,\n\t__dirname    : 1,\n\tBuffer       : 1,\n\tconsole      : 1,\n\texports      : 1,\n\tGLOBAL       : 1,\n\tglobal       : 1,\n\tmodule       : 1,\n\tprocess      : 1,\n\trequire      : 1,\n\tsetTimeout   : 1,\n\tclearTimeout : 1,\n\tsetInterval  : 1,\n\tclearInterval: 1\n};\n\nexports.LMD_GLOBALS = {\n\texports: 1,\n\tmodule: 1,\n\trequire: 1\n};\n\n// required to check string for being template\nvar templateParts = /<%|\\$\\{/,\n    reLmdFile = /\\.lmd\\.(json|js)$/,\n    globPattern = /\\*|\\{|\\}/,\n    maxInterpolateRecursion = 10;\n\nexports.RE_LMD_FILE = reLmdFile;\n\n/**\n * It uses _.template to interpolate config strings\n * {\n *   \"output\": \"index-<%= version %>.js\",\n *   \"version\": \"1.0.1\"\n * }\n *\n * ->\n *\n * {\n *   \"output\": \"index-1.0.1.js\",\n *   \"version\": \"1.0.1\"\n * }\n *\n * @param {Object} config\n * @param {Object} [data]\n *\n * @return {Object} config'\n */\nfunction interpolateConfigStrings(config, data) {\n    data = data || config;\n\n    for (var key in config) {\n        var value = config[key];\n\n        if (typeof value === \"object\") {\n            config[key] = interpolateConfigStrings(value, data);\n        } else if (typeof value === \"string\") {\n            var currentInterpolation = 0;\n            while (templateParts.test(value)) {\n                currentInterpolation++;\n                if (currentInterpolation > maxInterpolateRecursion) {\n                    break;\n                }\n                config[key] = value = template(value, data);\n            }\n        }\n    }\n\n    return config;\n}\n\nvar readConfig = function (file/*, filePart, filePart*/) {\n    file = path.join.apply(path, arguments);\n\n    var fileContent = fs.readFileSync(file, 'utf8'),\n        config;\n\n    if (path.extname(file) === '.json') {\n        // require() is Caches json files\n        config = JSON.parse(fileContent);\n    } else {\n        var mod = new Module('.', null);\n        mod.load(file);\n        config = mod.exports;\n    }\n\n    // Some extra variables\n    var data = {\n        __dirname: path.dirname(file),\n        __filename: file\n    };\n    for (var key in config) {\n        data[key] = config[key];\n    }\n\n    return interpolateConfigStrings(config, data);\n};\nexports.readConfig = readConfig;\n\n\nvar LMD_JS_SRC_PATH = path.join(__dirname, '../src');\nexports.LMD_JS_SRC_PATH = LMD_JS_SRC_PATH;\n\n\nvar LMD_PLUGINS = readConfig(LMD_JS_SRC_PATH, 'lmd_plugins.json');\nexports.LMD_PLUGINS = LMD_PLUGINS;\n\n/**\n * Merges mixins with config\n *\n * @param {Object} config\n * @param {String[]} mixins\n */\nvar mergeMixins = function (config, mixins) {\n    if (Array.isArray(config.mixins) && Array.isArray(mixins)) {\n        config.mixins.push.apply(config.mixins, mixins);\n        return config;\n    }\n\n    return deepDestructableMerge(config, {\n        mixins: mixins\n    });\n};\n\n/**\n * Config files deep merge\n *\n * @param {Object} left\n * @param {Object} right\n */\nvar deepDestructableMerge = function (left, right) {\n    for (var prop in right) {\n        if (right.hasOwnProperty(prop))  {\n            if (typeof left[prop] === \"object\") {\n                deepDestructableMerge(left[prop], right[prop]);\n            } else {\n                left[prop] = right[prop];\n            }\n        }\n    }\n    return left;\n};\nexports.deepDestructableMerge = deepDestructableMerge;\n\n/**\n * Merges all config files in module's lineage\n *\n * @param {Object} config\n * @param {String} configDir\n */\nvar tryExtend = function (config, configDir) {\n    config = config || {};\n    if (typeof config.extends !== \"string\") {\n        return config;\n    }\n\n    var parentConfig = tryExtend(readConfig(configDir, config.extends), configDir);\n\n    return deepDestructableMerge(parentConfig, config);\n};\nexports.tryExtend = tryExtend;\n\n/**\n * Returns depends config file of this module\n *\n * @param {String|Array} modulePath\n * @param {String}       dependsFileMask\n *\n * @return {Array}\n */\nvar getDependsConfigOf = function (modulePath, dependsFileMask) {\n    modulePath = [].concat(modulePath);\n\n    return modulePath.map(function (modulePath) {\n        var fileName = modulePath.replace(/^.*\\/|\\.[a-z0-9]+$/g, '');\n\n        return path.join(path.dirname(modulePath), dependsFileMask.replace('*', fileName));\n    });\n};\n\n/**\n * Merges configs flags\n *\n * @param {Object}   configA\n * @param {Object}   configB\n * @param {String[]} flagsNames\n * @param {Boolean}  isMasterConfig\n */\nvar mergeFlags = function (configA, configB, flagsNames, isMasterConfig) {\n    // Apply Flags\n    flagsNames.forEach(function (optionsName) {\n        // if master -> B\n        if (typeof configB[optionsName] === \"undefined\") {\n            return;\n        }\n\n        if (isMasterConfig) {\n            configA[optionsName] = configB[optionsName];\n        } else {\n            // if A literal B array -> B\n            if (configB[optionsName] instanceof Array && !(configA[optionsName] instanceof Array) ) {\n                configA[optionsName] = configB[optionsName];\n            } else if (configB[optionsName] instanceof Array && configA[optionsName] instanceof Array) {\n                // if A array B array -> A concat B\n                configA[optionsName] = configA[optionsName].concat(configB[optionsName]);\n            } else {\n                // if A literal B literal -> union\n                // if A array B literal -> A\n                configA[optionsName] = configA[optionsName] || configB[optionsName];\n            }\n            // else {}\n        }\n    });\n};\n\n/**\n *\n * @param {Object} moduleA\n * @param {Object} moduleB\n * @returns {boolean}\n */\nvar isModulesEqual = function (moduleA, moduleB) {\n    var fields = ['name', 'path', 'extra_exports', 'extra_require',\n        'extra_bind', 'is_multi_path_module', 'is_lazy', 'is_multi_path_module', 'depends'];\n\n    return moduleA && moduleB && fields.every(function (field) {\n        return moduleA[field] === moduleB[field];\n    });\n};\n\n/**\n * Merges configs\n *\n * @param {Object}   configA\n * @param {Object}   configB\n * @param {String[]} flagsNames\n * @param {Array}    inheritableFields\n * @param {Boolean}  isMasterConfig some parameters from configA will be overwritten using configB\n * @param {String}   context        configB description\n *\n * @return {*}\n */\nvar mergeConfigs = function (configA, configB, flagsNames, inheritableFields, isMasterConfig, context) {\n    if (isMasterConfig) {\n        // Apply master fields\n        inheritableFields.forEach(function (fieldName) {\n            if (typeof configB[fieldName] !== \"undefined\") {\n                configA[fieldName] = configB[fieldName];\n                if (FILED_ALIASES.hasOwnProperty(fieldName)) {\n                    configA[FILED_ALIASES[fieldName]] = configB[fieldName];\n                }\n            }\n        });\n    }\n\n    // Save errors\n    configA.errors = configA.errors || [];\n    configB.errors = configB.errors || [];\n    configA.errors = configA.errors.concat(configB.errors);\n\n    // Apply Flags\n    mergeFlags(configA, configB, flagsNames, isMasterConfig);\n\n    // Apply Modules\n    configA.modules = configA.modules || {};\n    configB.modules = configB.modules || {};\n    for (var moduleName in configB.modules) {\n        // Warn if module exists an its not a master config\n        if (!isMasterConfig && configA.modules[moduleName]) {\n            if (!isModulesEqual(configA.modules[moduleName], configB.modules[moduleName])) {\n                configA.errors.push('Name conflict! Module **\"' + moduleName + '\"** will be overwritten by ' + context);\n            }\n        }\n        configA.modules[moduleName] = configB.modules[moduleName];\n    }\n\n    // Apply styles\n    configA.styles = configA.styles || [];\n    configB.styles = configB.styles || [];\n    configA.styles = configA.styles.concat(configB.styles);\n\n    // Apply Bundles\n    configA.bundles = configA.bundles || {};\n    configB.bundles = configB.bundles || {};\n    for (var bundleName in configB.bundles) {\n        if (configB.bundles[bundleName]) {\n            if (!configA.bundles[bundleName]) {\n                configA.bundles[bundleName] = {};\n            }\n            // Bundle is not exists\n            if (configB.bundles[bundleName] instanceof Error) {\n                configA.bundles[bundleName] = configB.bundles[bundleName];\n            } else {\n                mergeConfigs(configA.bundles[bundleName], configB.bundles[bundleName], flagsNames, MASTER_FIELDS, true, context);\n            }\n        }\n    }\n\n    // Apply User Plugins\n    configA.plugins = configA.plugins || {};\n    configB.plugins = configB.plugins || {};\n    for (var pluginName in configB.plugins) {\n        // Warn if module exists an its not a master\n        if (!isMasterConfig && configA.plugins[pluginName]) {\n            configA.errors.push('Name conflict! User plugin **\"' + pluginName + '\"** will be overwritten by ' + context);\n        }\n        configA.plugins[pluginName] = configB.plugins[pluginName];\n    }\n\n    return configA; // not rly need...\n};\n\n/**\n * Creates LMD config: applies depends and extends\n *\n * @param {Object}   rawConfig\n * @param {String}   configFile\n * @param {String}   configDir\n * @param {String[]} [flagsNames]\n * @param {Object}   [extraOptions]\n * @param {Object}   [usedConfigs]\n *\n * @return {Object}\n */\nvar assembleLmdConfigAsObject = function (rawConfig, configFile, configDir, flagsNames, extraOptions, usedConfigs) {\n    flagsNames = flagsNames || Object.keys(LMD_PLUGINS);\n\n    var isFirstRun = typeof usedConfigs === \"undefined\";\n\n    usedConfigs = usedConfigs || {};\n    usedConfigs[configFile] = true; // mark config as used\n\n    var configs = [],\n        resultConfig = {\n            modules: {},\n            errors: [],\n            plugins_depends: {}\n        };\n\n    if (extraOptions && extraOptions.mixins) {\n        rawConfig = mergeMixins(rawConfig, extraOptions.mixins);\n    }\n\n    if (extraOptions && extraOptions.styles) {\n        rawConfig = deepDestructableMerge(rawConfig, {\n            styles: extraOptions.styles\n        });\n    }\n\n    // collect modules and module options\n    var modules = collectModules(rawConfig, configDir);\n    if (rawConfig.depends) {\n        var /*dependsMask = rawConfig.depends === true ? DEFAULT_DEPENDS_MASK : rawConfig.depends,*/\n            dependsConfigPath,\n            dependsMask;\n        for (var moduleName in modules) {\n            if (!modules[moduleName].is_shortcut && !modules[moduleName].is_ignored) {\n                dependsMask = modules[moduleName].depends;\n                dependsConfigPath = getDependsConfigOf(modules[moduleName].path, dependsMask);\n                dependsConfigPath.forEach(function (dependsConfigPath) {\n                    if (fileExists(dependsConfigPath)) {\n                        if (!usedConfigs[dependsConfigPath]) {\n                            configs.unshift({\n                                context: 'depends config **' + dependsConfigPath + '**',\n                                config: assembleLmdConfig(dependsConfigPath, flagsNames, null, usedConfigs)\n                            });\n                        }\n                    }\n                });\n            }\n        }\n    }\n\n    // extend parent config\n    if (typeof rawConfig['extends'] === \"string\") {\n        var parentConfigFile = fs.realpathSync(configDir + '/' + rawConfig['extends']);\n        if (!usedConfigs[parentConfigFile]) {\n            var parentConfig = assembleLmdConfig(parentConfigFile, flagsNames, null, usedConfigs);\n        }\n    }\n\n    var processedConfig = {\n        modules: modules,\n        styles: collectStyles(rawConfig, configDir),\n        bundles: collectBundles(rawConfig, configDir),\n        plugins: collectUserPlugins(rawConfig, configDir)\n    };\n\n    // keep fields\n    MASTER_FIELDS.forEach(function (fieldName) {\n        processedConfig[fieldName] = rawConfig[fieldName];\n        if (FILED_ALIASES.hasOwnProperty(fieldName)) {\n            processedConfig[FILED_ALIASES[fieldName]] = rawConfig[fieldName];\n        }\n    });\n\n    // keep flags\n    flagsNames.forEach(function (fieldName) {\n        processedConfig[fieldName] = rawConfig[fieldName];\n    });\n\n    if (parentConfig) {\n        mergeConfigs(resultConfig, parentConfig, flagsNames, INHERITABLE_FIELDS, true, 'parent config **' + parentConfigFile + '**');\n    }\n\n    for (var i = 0, c = configs.length, dependsMainModuleName; i < c; i++) {\n        // Cleanup main module from depends\n        dependsMainModuleName = configs[i].config.main || \"main\";\n        if (configs[i].config.modules) {\n            delete configs[i].config.modules[dependsMainModuleName];\n        }\n        mergeConfigs(resultConfig, configs[i].config, flagsNames, [], false, configs[i].context);\n    }\n\n    mergeConfigs(resultConfig, processedConfig, flagsNames, MASTER_FIELDS, true, 'main config **' + configFile + '**');\n\n    if (isFirstRun) {\n        // Apply mixins\n        var mixins = resultConfig.mixins;\n        if (Array.isArray(mixins)) {\n            mixins.forEach(function (mixinName) {\n                var mixinConfigFile = fs.realpathSync(configDir + '/' + mixinName),\n                    processedMixin = assembleLmdConfig(mixinConfigFile, flagsNames, null, usedConfigs);\n\n                mergeConfigs(resultConfig, processedMixin, flagsNames, INHERITABLE_FIELDS, true, 'mixin config **' + mixinConfigFile + '**');\n            });\n        }\n        if (extraOptions) {\n            extraOptions.modules = collectModules(extraOptions, configDir);\n            extraOptions.bundles = collectBundles(extraOptions, configDir);\n            extraOptions.styles = collectStyles(extraOptions, configDir);\n            mergeConfigs(resultConfig, extraOptions, flagsNames, EXTRA_OPTIONS_FIELDS, true, 'CLI options');\n        }\n        reapplyModuleOptions(resultConfig);\n        addPluginsFromBundles(resultConfig);\n        addPluginsDepends(resultConfig);\n        flattenBundles(resultConfig);\n        resolveStyles(resultConfig);\n        bundlesInheritFieldsFromPackage(resultConfig);\n        removeIgnoredModules(resultConfig);\n    }\n    return resultConfig;\n};\n\n/**\n * Creates LMD config: applies depends and extends\n *\n * @param {Object}   configFile\n * @param {String[]} [flagsNames]\n * @param {Object}   [extraOptions]\n * @param {Object}   [usedConfigs]\n *\n * @return {Object}\n */\nvar assembleLmdConfig = function (configFile, flagsNames, extraOptions, usedConfigs) {\n    var configDir = path.dirname(configFile),\n        rawConfig = readConfig(configFile);\n\n    configFile = fs.realpathSync(configFile);\n    return assembleLmdConfigAsObject(rawConfig, configFile, configDir, flagsNames, extraOptions, usedConfigs);\n};\nexports.assembleLmdConfig = assembleLmdConfig;\n\n/**\n * Resolve and add all plugins depends\n *\n * @param resultConfig\n */\nfunction addPluginsDepends(resultConfig) {\n    for (var pluginName in LMD_PLUGINS) {\n        if (typeof resultConfig[pluginName] !== \"undefined\") {\n            addOnePluginDepends(pluginName, resultConfig);\n        }\n    }\n}\n\n/**\n * For now add plugins from build to bundle\n *\n * @param resultConfig\n */\nfunction addPluginsFromBundles(resultConfig) {\n    if (resultConfig.bundles) {\n        var bundles = Object.keys(resultConfig.bundles),\n            lmdPlugins = Object.keys(LMD_PLUGINS);\n\n        // Apply flags from bundles\n        bundles.forEach(function (bundleName) {\n            mergeFlags(resultConfig, resultConfig.bundles[bundleName], lmdPlugins, false);\n        });\n\n        // Set bundle plugin\n        if (bundles.length) {\n            resultConfig.bundle = true;\n        }\n    }\n}\n\n/**\n *\n * @param config\n * @param {String} [namespace]\n */\nfunction flattenBundles(config, namespace) {\n    namespace = namespace || '';\n    var bundles = {};\n\n    if (!config.bundles) {\n        return;\n    }\n    Object.keys(config.bundles).forEach(function (bundleName) {\n        var bundle = config.bundles[bundleName];\n        bundles[namespace + bundleName] = bundle;\n        // Flatten sub-bundles\n        if (bundle.bundles) {\n            flattenBundles(bundle, bundleName + SUB_BUNDLE_SEPARATOR);\n            var subBundles = bundle.bundles;\n            for (var subBundleName in subBundles) {\n                bundles[subBundleName] = subBundles[subBundleName];\n            }\n            delete bundle.bundles;\n        }\n    });\n\n    config.bundles = bundles;\n}\n\nfunction resolveStyles(config) {\n    function unique(array, item) {\n        if (array.indexOf(item) < 0) {\n            array.push(item);\n        }\n        return array;\n    }\n\n    config.styles = config.styles\n        .reduce(unique, [])\n        // resolve full paths\n        .reduce(function (styles, cssPath) {\n            var someStyles = [cssPath];\n\n            if (globPattern.test(cssPath)) {\n                someStyles = glob.sync(cssPath, {\n                    nosort: true\n                }) || someStyles;\n            }\n\n            return styles.concat(someStyles);\n        }, [])\n        .reduce(unique, [])\n        .map(function (path) {\n            return {\n                path: path,\n                is_exists: fs.existsSync(path)\n            };\n        });\n}\n\nfunction collectUserPlugins(resultConfig, configDir) {\n    var plugins = resultConfig.plugins,\n        collectedPlugins = {};\n\n    if (typeof plugins !== \"object\") {\n        return collectedPlugins;\n    }\n\n    var rootDir = path.resolve(configDir, resultConfig.path || resultConfig.root),\n        invalidPluginNames = [],\n        plugin,\n        pluginName,\n        pluginOriginalPath,\n        pluginPath,\n        pluginExists,\n        pluginConflict,\n        pluginValid,\n        pluginOptions,\n        pluginCode;\n\n    // format plugin descriptor struct\n    for (pluginName in plugins) {\n        plugin = plugins[pluginName];\n\n        pluginOptions = (typeof plugin === \"string\" ? null : plugin.options) || null;\n        pluginOriginalPath = (typeof plugin === \"string\" ? plugin : plugin.path) || '';\n        pluginPath = path.join(rootDir, pluginOriginalPath);\n        pluginExists = true;\n\n        try {\n            pluginPath = fs.realpathSync(pluginPath);\n        } catch (e) {\n            pluginExists = false;\n        }\n\n        pluginConflict = pluginName in LMD_PLUGINS;\n        pluginValid = false;\n        pluginCode = null;\n        if (!pluginConflict && pluginExists) {\n            pluginCode = fs.readFileSync(pluginPath, 'utf8');\n            pluginValid = validateUserPlugin(pluginCode);\n        }\n\n        collectedPlugins[pluginName] = {\n            name: pluginName,\n            isConflict: pluginConflict,\n            isExists: pluginExists,\n            isValid: pluginValid,\n            isOk: !pluginConflict && pluginExists && pluginValid,\n            originalPath: pluginOriginalPath,\n            path: pluginPath,\n            code: pluginCode,\n            options: pluginOptions\n        };\n    }\n\n    return collectedPlugins;\n}\n\nfunction validateUserPlugin(code) {\n    var ast;\n\n    try {\n        ast = parser.parse(code);\n    } catch (e) {\n        return e.toString();\n    }\n\n    // should match this pattern\n    // [\"toplevel\", [[\"stat\", [\"call\", [\"function\", null, [\"sb\"],[*]],[[\"name\", \"sandbox\"]]]]]];\n    return (\n        ast && ast.length === 2 &&\n        ast[1] && ast[1].length === 1 &&\n        ast[1][0][0] === \"stat\" &&\n        ast[1][0][1] &&\n        ast[1][0][1][0] === \"call\" &&\n        ast[1][0][1][1] &&\n        ast[1][0][1][1][0] === \"function\"\n    );\n}\n\nfunction addOnePluginDepends(pluginName, resultConfig) {\n    var plugin = LMD_PLUGINS[pluginName];\n    if (plugin.depends) {\n        plugin.depends.forEach(function (flagName) {\n            // check that depends is plugin and that plugin is not included\n            if (flagName in LMD_PLUGINS && typeof resultConfig[flagName] === \"undefined\") {\n                // add flag as true\n                resultConfig[flagName] = true;\n\n                // add flag to plugins_depends list\n                if (!resultConfig.plugins_depends[flagName]) {\n                    resultConfig.plugins_depends[flagName] = [];\n                }\n                resultConfig.plugins_depends[flagName].push(pluginName);\n\n                // recursively check plugin depends\n                addOnePluginDepends(flagName, resultConfig);\n            }\n        });\n    }\n}\n\nfunction isCoverage(config, moduleName) {\n    if (!config.stats_coverage) {\n        return false;\n    }\n\n    if (config.stats_coverage === true) {\n        return true;\n    }\n\n    if (config.stats_coverage instanceof Array) {\n        return config.stats_coverage.indexOf(moduleName) !== -1;\n    }\n\n    return false;\n}\n\nfunction subdirToString() {\n    return this.length > 0 ? this.reverse().join('/') + '/' : '';\n}\n\nfunction createSubdirTemplateVariable(modulesDirPath, moduleRealPath) {\n    var subdir = path.dirname(path.relative(modulesDirPath, moduleRealPath)).split(path.sep).reverse();\n\n    if (subdir[0] === '.') {\n        subdir = [];\n    }\n\n    subdir.toString = subdirToString;\n    return subdir;\n}\n\n/**\n * @name LmdModuleStruct\n * @class\n *\n * @field {String}  name            module name\n * @field {String}  path            full path to module\n * @field {String}  depends         depends file mask\n * @field {Boolean} is_lazy         is lazy module?\n * @field {Boolean} is_sandbox      is module sandboxed?\n * @field {Boolean} is_greedy       module is collected using wildcard\n * @field {Boolean} is_shortcut     is module shortcut?\n * @field {Boolean} is_coverage     is module under code coverage?\n * @field {Boolean} is_third_party  uses custom export/require?\n *\n */\n\n/**\n * Collecting module using merged config\n *\n * @param config\n *\n * @returns {Object}\n */\nvar collectModules = function (config, configDir) {\n    var modules = {},\n        globalLazy = config.lazy || false,\n        globalDepends = (config.depends === true ? DEFAULT_DEPENDS_MASK : config.depends) || false,\n        moduleLazy = false,\n        moduleTypeHint,\n        moduleName,\n        modulePath,\n        moduleRealPath,\n        moduleExists,\n        moduleExports,\n        moduleRequire,\n        moduleBind,\n        moduleFileName,\n        moduleFilePath,\n        moduleDesciptor,\n        wildcardRegex,\n        isMultiPathModule,\n        moduleData,\n        isThirdPartyModule,\n        modulesDirPath = config.root || config.path || '';\n\n    modulesDirPath = path.resolve(configDir, modulesDirPath);\n\n    // grep paths\n    for (moduleName in config.modules) {\n        moduleDesciptor = config.modules[moduleName];\n        // case \"moduleName\": null\n        // case \"moduleName\": \"path/to/module.js\"\n        if (moduleDesciptor === null || typeof moduleDesciptor === \"string\" || Array.isArray(moduleDesciptor)) {\n            moduleTypeHint = false;\n            moduleExports = false;\n            moduleRequire = false;\n            moduleBind = false;\n            modulePath = moduleDesciptor;\n            moduleLazy = globalLazy;\n        } else { // case \"moduleName\": {\"path\": \"path/to/module.js\", \"lazy\": false}\n            moduleTypeHint = moduleDesciptor.type || false;\n            moduleExports = moduleDesciptor.exports || false;\n            moduleRequire = moduleDesciptor.require || false;\n            moduleBind = moduleDesciptor.bind || moduleDesciptor['this'] || false;\n            modulePath = moduleDesciptor.path;\n            moduleLazy = moduleDesciptor.lazy || false;\n            moduleTypeHint = moduleDesciptor.type || false;\n        }\n\n        isMultiPathModule = false;\n        if (Array.isArray(modulePath)) {\n            // Try to glob\n            // case when ['jquery*.js']\n            modulePath = modulePath.reduce(function (paths, modulePath) {\n                if (globPattern.test(modulePath)) {\n                    modulePath = glob.sync(modulePath, {\n                        cwd: modulesDirPath,\n                        nosort: true\n                    }) || [];\n                }\n\n                return paths.concat(modulePath);\n            }, []);\n\n            // case when ['jquery.js']\n            if (modulePath.length === 1) {\n                modulePath = modulePath[0];\n            } else {\n                isMultiPathModule = true;\n            }\n        }\n\n        isThirdPartyModule = !!moduleExports || !!moduleRequire || !!moduleBind;\n\n        // Override if cache flag = true\n        if (config.cache) {\n            moduleLazy = true;\n        }\n\n        // its a glob pattern\n        // @see https://github.com/isaacs/node-glob\n        if (!isMultiPathModule && globPattern.test(modulePath)) {\n            var globModules = glob.sync(modulePath, {\n                cwd: modulesDirPath,\n                nosort: true\n            });\n\n            // * -> <%= file => for backward capability\n            var moduleNameTemplate = template(moduleName.replace('*', '<%= file %>'));\n\n            globModules.forEach(function (module) {\n                var moduleRealPath = path.join(modulesDirPath, module),\n                    basename = path.basename(moduleRealPath),\n                    fileParts = basename.split('.'),\n                    ext = fileParts.pop(),\n                    file = fileParts.join('.'),\n                    dir = path.dirname(moduleRealPath).split(path.sep).reverse(),\n                    subdir = createSubdirTemplateVariable(modulesDirPath, moduleRealPath);\n\n                // modify module name using template\n                var newModuleName = moduleNameTemplate({\n                    basename: basename,\n                    file: file,\n                    ext: ext,\n                    dir: dir,\n                    subdir: subdir\n                });\n\n                moduleExists = true;\n                try {\n                    moduleRealPath = fs.realpathSync(moduleRealPath);\n                } catch (e) {\n                    moduleExists = false;\n                }\n\n                moduleData = {\n                    originalModuleDesciptor: moduleDesciptor,\n                    name: newModuleName,\n                    path: moduleRealPath,\n                    originalPath: modulePath,\n                    lines: 0,\n                    extra_exports: moduleExports,\n                    extra_require: moduleRequire,\n                    extra_bind: moduleBind,\n                    type_hint: moduleTypeHint,\n                    is_exists: moduleExists,\n                    is_third_party: isThirdPartyModule,\n                    is_lazy: moduleLazy,\n                    is_greedy: true,\n                    is_shortcut: false,\n                    is_coverage: isCoverage(config, newModuleName),\n                    is_ignored: false,\n                    is_sandbox: moduleDesciptor.sandbox || false,\n                    is_multi_path_module: isMultiPathModule,\n                    depends: typeof moduleDesciptor.depends === \"undefined\" ? globalDepends : moduleDesciptor.depends\n                };\n\n                // wildcard have a low priority\n                // if module was directly named it pass\n                if (!(modules[newModuleName] && !modules[newModuleName].is_greedy)) {\n                    modules[newModuleName] = moduleData;\n                }\n            });\n        } else if (!isMultiPathModule && /^@/.test(modulePath)) {\n            // shortcut\n            modules[moduleName] = {\n                originalModuleDesciptor: moduleDesciptor,\n                name: moduleName,\n                originalPath: modulePath,\n                lines: 0,\n                path: modulePath,\n                extra_exports: moduleExports,\n                extra_require: moduleRequire,\n                extra_bind: moduleBind,\n                type_hint: moduleTypeHint,\n                is_exists: true,\n                is_third_party: isThirdPartyModule,\n                is_lazy: moduleLazy,\n                is_greedy: false,\n                is_shortcut: true,\n                is_coverage: false,\n                is_ignored: false,\n                is_sandbox: moduleDesciptor.sandbox || false,\n                is_multi_path_module: isMultiPathModule,\n                depends: typeof moduleDesciptor.depends === \"undefined\" ? globalDepends : moduleDesciptor.depends\n            };\n        } else if (modulePath === null) {\n            modules[moduleName] = {\n                originalModuleDesciptor: moduleDesciptor,\n                name: moduleName,\n                originalPath: modulePath,\n                lines: 0,\n                path: modulePath,\n                extra_exports: moduleExports,\n                extra_require: moduleRequire,\n                extra_bind: moduleBind,\n                type_hint: moduleTypeHint,\n                is_exists: true,\n                is_third_party: false,\n                is_lazy: false,\n                is_greedy: false,\n                is_shortcut: false,\n                is_coverage: false,\n                is_ignored: true,\n                is_sandbox: false,\n                is_multi_path_module: false,\n                depends: globalDepends\n            };\n        } else {\n            modulePath = [].concat(modulePath);\n            moduleExists = true;\n\n            moduleRealPath = modulePath\n                .map(function (modulePath) {\n                    return path.join(modulesDirPath, modulePath);\n                })\n                .map(function (moduleRealPath) {\n                    try {\n                        return fs.realpathSync(moduleRealPath);\n                    } catch (e) {\n                        moduleExists = false;\n                    }\n                    return moduleRealPath;\n                });\n\n            // normal name\n            // \"name\": \"name.js\"\n            modules[moduleName] = {\n                originalModuleDesciptor: moduleDesciptor,\n                name: moduleName,\n                path: isMultiPathModule ? moduleRealPath : moduleRealPath[0],\n                originalPath: isMultiPathModule ? modulePath : modulePath[0],\n                lines: 0,\n                extra_exports: moduleExports,\n                extra_require: moduleRequire,\n                extra_bind: moduleBind,\n                type_hint: moduleTypeHint,\n                is_exists: moduleExists,\n                is_third_party: isThirdPartyModule,\n                is_lazy: moduleLazy,\n                is_greedy: false,\n                is_shortcut: false,\n                // Cant use code coverage with multi path module\n                is_coverage: !isMultiPathModule && isCoverage(config, moduleName),\n                is_ignored: false,\n                is_sandbox: moduleDesciptor.sandbox || false,\n                is_multi_path_module: isMultiPathModule,\n                depends: typeof moduleDesciptor.depends === \"undefined\" ? globalDepends : moduleDesciptor.depends\n            };\n        }\n    }\n\n    return modules;\n};\nexports.collectModules = collectModules;\n\nvar bundlesInheritFieldsFromPackage = function (resultConfig) {\n    var bundles = resultConfig.bundles || {};\n\n    Object.keys(bundles).forEach(function (bundleName) {\n        bundleInheritFieldsFromPackage(bundleName, bundles[bundleName], resultConfig);\n    });\n};\n\nvar bundleInheritFieldsFromPackage = function (bundleName, bundle, config) {\n    BUNDLE_INHERIT_FROM_PACKAGE.forEach(function (name) {\n        if (typeof bundle[name] === \"undefined\" && typeof config[name] !== \"undefined\") {\n            bundle[name] = config[name];\n        }\n    });\n\n    // Set output path\n    if (typeof bundle.output === 'undefined' && config.output) {\n        // using parent output, set output path for bundle\n        // ../index.js -> ../index.%bundleName%.js\n        bundle.output = config.output.replace(/\\.js$/, '') + '.' + bundleName + '.js';\n    }\n\n    if (typeof bundle.styles_output === 'undefined' && config.styles_output) {\n        // using parent output, set output path for bundle\n        // ../index.css -> ../index.%bundleName%.css\n        bundle.styles_output = config.styles_output.replace(/\\.css$/, '') + '.' + bundleName + '.css';\n    }\n\n    if (typeof bundle.styles_output === 'undefined' && config.output) {\n        // using parent output, set output path for bundle\n        // ../index.js -> ../index.%bundleName%.css\n        bundle.styles_output = config.output.replace(/\\.js$/, '') + '.' + bundleName + '.css';\n    }\n\n    // Set sourcemap\n    if (bundle.output && config.sourcemap) {\n        bundle.sourcemap = bundle.output.replace(/\\.js/, '') + '.map';\n        bundle.sourcemap_inline = bundle.sourcemap_inline || config.sourcemap_inline;\n        bundle.sourcemap_www = bundle.sourcemap_www || config.sourcemap_www;\n        bundle.sourcemap_url = bundle.sourcemap_url || config.sourcemap_url;\n    }\n\n    // Continue inherit\n    bundlesInheritFieldsFromPackage(bundle);\n};\n\nvar removeIgnoredModules = function (resultConfig) {\n    var modules = resultConfig.modules;\n    for (var moduleName in modules) {\n        if (modules[moduleName].is_ignored) {\n            delete modules[moduleName];\n        }\n    }\n};\n\nvar collectStyles = function (config, configDir) {\n    return (config.styles || []).map(function (style) {\n        return path.join(path.resolve(configDir, config.root || ''), style);\n    });\n};\n\nvar collectBundles = function (config, configDir) {\n    var bundles = {},\n        bundleName,\n        bundlePath,\n        bundle,\n        pluginNames = Object.keys(LMD_PLUGINS),\n        options = {};\n\n    for (bundleName in config.bundles) {\n        bundle = config.bundles[bundleName];\n        // Path to lmd.js file\n        if (typeof bundle === \"string\") {\n            bundlePath = path.join(configDir, bundle);\n            if (fileExists(bundlePath)) {\n                bundle = assembleLmdConfig(bundlePath, pluginNames, options);\n                bundleInheritFieldsFromPackage(bundleName, bundle, config);\n            } else {\n                // not found\n                bundle = new Error(bundlePath);\n            }\n        } else {\n            bundleInheritFieldsFromPackage(bundleName, bundle, config);\n            bundle = assembleLmdConfigAsObject(bundle, 'Bundle: ' + bundleName, configDir, pluginNames, options);\n        }\n\n        // Keep sub-bundles\n        bundles[bundleName] = bundle;\n    }\n\n    return bundles;\n};\n\nvar reapplyModuleOptions = function (config) {\n    var globalLazy = config.lazy || false,\n        moduleName,\n        moduleDesciptor,\n        moduleLazy;\n\n    for (moduleName in config.modules) {\n        moduleDesciptor = config.modules[moduleName].originalModuleDesciptor;\n\n        if (typeof moduleDesciptor === \"string\" || moduleDesciptor === null) {\n            moduleLazy = globalLazy;\n        } else {\n            moduleLazy = moduleDesciptor.lazy || false;\n        }\n\n        // Override if cache flag = true\n        if (config.cache) {\n            moduleLazy = true;\n        }\n\n        delete config.modules[moduleName].originalModuleDesciptor;\n        config.modules[moduleName].is_lazy = moduleLazy;\n        config.modules[moduleName].is_coverage = isCoverage(config, moduleName);\n    }\n};\n\n/**\n *\n * @param {Object} config\n * @returns {Object}\n */\nvar collectModulesInfo = function (config) {\n    var result = {};\n\n    var bundles = groupModulesByBundles(config);\n    iterateModulesInfo(bundles, function (moduleOptions, moduleName, bundleName) {\n        if (!result[bundleName]) {\n            result[bundleName] = {};\n        }\n        result[bundleName][moduleName] = analiseModuleContent(moduleOptions);\n    });\n\n    return result;\n};\nexports.collectModulesInfo = collectModulesInfo;\n\n/**\n * Wrapper for plain files\n *\n * @param {String} code\n *\n * @returns {String} wrapped code\n */\nvar wrapPlainModule = function (code) {\n    return '(function (require, exports, module) { /* wrapped by builder */\\n' + code + '\\n})';\n};\n\n/**\n * Wrapper for AMD files\n *\n * @param {String} code\n *\n * @returns {String} wrapped code\n */\nvar wrapAmdModule = function (code) {\n    return '(function (require) { /* wrapped by builder */\\nvar define = require.define;\\n' + code + '\\n})';\n};\n\n/**\n * Wrapper for non-lmd modules files\n *\n * @param {String}               code\n * @param {Object}               options\n * @param {Object|String}        options.extra_exports\n * @param {Object|String|String} options.extra_require\n * @param {Object|String|String} options.extra_bind\n *\n * @returns {String} wrapped code\n */\nvar wrap3partyModule = function (code, options) {\n    var exports = [],\n        requires = [],\n        bind = [],\n        extra_exports = options.extra_exports,\n        extra_require = options.extra_require,\n        extra_bind = options.extra_bind,\n        exportCode,\n        bindModuleName;\n\n    // add exports to the module end\n    // extra_exports = {name: code, name: code}\n    if (typeof extra_exports === \"object\") {\n        for (var exportName in extra_exports) {\n            exportCode = extra_exports[exportName];\n            exports.push('    ' + JSON.stringify(exportName) + ': ' + exportCode);\n        }\n        code += '\\n\\n/* added by builder */\\nreturn {\\n' + exports.join(',\\n') + '\\n};';\n    } else if (extra_exports) {\n        // extra_exports = string\n        code += '\\n\\n/* added by builder */\\nreturn ' + extra_exports + ';';\n    }\n\n    // change context of module (this)\n    // and proxy return value\n    // return function(){}.call({name: require('name')});\n    if (typeof extra_bind === \"object\") {\n        for (var bindName in extra_bind) {\n            bindModuleName = extra_bind[bindName];\n            bind.push('    ' + JSON.stringify(bindName) + ': require(' + JSON.stringify(bindModuleName) + ')');\n        }\n        code = '\\nreturn function(){\\n\\n' + code + '\\n}.call({\\n' + bind.join(',\\n') + '\\n});';\n    } else if (extra_bind) {\n        // return function(){}.call(require('name'));\n        code = '\\nreturn function(){\\n\\n' + code + '\\n}.call(require(' + JSON.stringify(extra_bind) + '));';\n    }\n\n    // add require to the module start\n    if (typeof extra_require === \"object\") {\n        // extra_require = [name, name, name]\n        if (extra_require instanceof Array) {\n            for (var i = 0, c = extra_require.length, moduleName; i < c; i++) {\n                moduleName = extra_require[i];\n                requires.push('require(' + JSON.stringify(moduleName) + ');');\n            }\n            code = '/* added by builder */\\n' + requires.join('\\n') + '\\n\\n' + code;\n        } else {\n            // extra_require = {name: name, name: name}\n            for (var localName in extra_require) {\n                moduleName = extra_require[localName];\n                requires.push(localName + ' = require(' + JSON.stringify(moduleName) + ')');\n            }\n            code = '/* added by builder */\\nvar ' + requires.join(',\\n    ') + ';\\n\\n' + code;\n        }\n    } else if (extra_require) {\n        // extra_require = string\n        code = '/* added by builder */\\nrequire(' + JSON.stringify(extra_require) + ');\\n\\n' + code;\n    }\n\n    return '(function (require) { /* wrapped by builder */\\n' + code + '\\n})';\n};\n\n/**\n * Removes tail semicolons\n *\n * @param {String} code\n *\n * @return {String}\n */\nvar removeTailSemicolons = function (code) {\n    return code.replace(/\\n*;\\n*$/, '');\n};\n\n/**\n * Aggregates all module wrappers\n *\n * @param code\n * @param moduleOptions\n * @param moduleType\n *\n * @return {String}\n */\nvar wrapModule = function (code, moduleOptions, moduleType) {\n    switch (moduleType) {\n        case \"3-party\":\n            // create lmd module from non-lmd module\n            code = wrap3partyModule(code, moduleOptions);\n            break;\n\n        case \"plain\":\n            // wrap plain module\n            code = wrapPlainModule(code);\n            break;\n\n        case \"amd\":\n            // AMD RequireJS\n            code = wrapAmdModule(code);\n            break;\n\n        case \"fd\":\n        case \"fe\":\n            // wipe tail ;\n            code = removeTailSemicolons(code);\n    }\n\n    return code;\n};\nexports.wrapModule = wrapModule;\n\nvar astLookupExtraRequireName = function (ast, itemIndex) {\n    if (ast[itemIndex][0] === \"array\") {\n        var index = -1;\n        ast[itemIndex][1].forEach(function (item, i) {\n            if (item[1] === \"require\") {\n                index = i;\n            }\n        });\n\n        // get require index\n        if (index !== -1) {\n            if (ast[itemIndex + 1][0] === \"function\") {\n                return ast[itemIndex + 1][2][index];\n            }\n        }\n    } else if (ast[itemIndex][0] === \"function\") {\n        return ast[itemIndex][2][0];\n\n    } else if (ast[itemIndex][0] === \"string\") {\n        if (ast[itemIndex + 1]) {\n            return astLookupExtraRequireName(ast, itemIndex + 1);\n        }\n    }\n};\n\nvar findLastDefine = function (ast) {\n    var define = uglify.ast_walker(),\n        lastDefineAst;\n\n    define.with_walkers({\n        \"call\": function () {\n            if (this[1][0] === \"name\" && this[1][1] === \"define\") {\n                lastDefineAst = this;\n            }\n        }\n    }, function () {\n        return define.walk(ast);\n    });\n\n    return lastDefineAst;\n};\n\nvar findRequireAccesses = function (ast, moduleType) {\n    var requireName,\n        extraRequireName,\n        requireAccesses = [];\n\n    switch (moduleType) {\n        case \"plain\":\n        case \"3-party\":\n            requireName = \"require\";\n            break;\n        case \"amd\":\n            requireName = \"require\";\n\n            var lastDefineAst = findLastDefine(ast);\n\n            if (lastDefineAst) {\n               extraRequireName = astLookupExtraRequireName(lastDefineAst[2], 0);\n            }\n            break;\n        case \"fd\":\n        case \"fe\":\n            if (ast[1] && ast[1][0] && ast[1][0][0] === \"stat\") {\n                requireName = ast[1] && ast[1][0] && ast[1][0][1] && ast[1][0][1][2] && ast[1][0][1][2][0];\n            } else {\n                requireName = ast[1] && ast[1][0] && ast[1][0][2] && ast[1][0][2][0];\n            }\n\n            break;\n        default:\n            return requireAccesses;\n    }\n\n    var walker = uglify.ast_walker();\n\n    walker.with_walkers({\n        \"name\": function () {\n            if (this[1] === requireName || this[1] === extraRequireName) {\n\n                var stack = walker.stack(),\n                    last = stack.length - 1;\n\n                while (last >= 0) {\n                    /*\n                    [\"var\", [\n                        [\"x\", [\"dot\", [\"name\", \"require\"], \"js\"]],\n                        [\"y\"]\n                    ]],\n                    [\"dot\", [\"name\", \"require\"], \"js\"],\n                    [\"name\", \"require\"]\n                    */\n\n                    /*\n                    [\"assign\", true, [\"name\", \"y\"],\n                        [\"dot\", [\"name\", \"require\"], \"css\"]\n                    ],\n                    [\"dot\", [\"name\", \"require\"], \"css\"],\n                    [\"name\", \"require\"]\n                    */\n                    if (stack[last][0] === \"assign\" || stack[last][0] === \"var\") {\n                        requireAccesses.push(stack[last + 1]);\n                        break;\n                    }\n\n                    /*\n                    [\"call\", [\"dot\", [\"name\", \"require\"], \"define\"],\n                        [\n                            [\"function\", null, [],\n                                []\n                            ]\n                        ]\n                    ],\n                    [\"dot\", [\"name\", \"require\"], \"define\"],\n                    [\"name\", \"require\"]\n                    */\n                    if (stack[last][0] === \"call\") {\n                        requireAccesses.push(stack[last]);\n                        // add parent also for require.js().then()\n                        if (stack[last - 1]) {\n                            requireAccesses.push(stack[last - 1]);\n                        }\n                        break;\n                    }\n                    last--;\n                }\n            }\n        }\n    }, function () {\n        return walker.walk(ast);\n    });\n\n    return requireAccesses;\n};\n\nvar findModuleRequirementsAndFeatures = function (requireExpressions) {\n    var features = {},\n        depends = [];\n\n    requireExpressions.forEach(function (requireAst) {\n        var nameAst = requireAst[0] === \"call\" ? requireAst[1] : requireAst,\n            currentIsAsyncFunction = false,\n            currentIsMatch = false;\n\n        // js           [ 'dot', [ 'name', 'require' ], 'js' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"js\") {\n            features.js = true;\n            currentIsAsyncFunction = true;\n        }\n        // css          [ 'dot', [ 'name', 'require' ], 'css' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"css\") {\n            features.css = true;\n            currentIsAsyncFunction = true;\n        }\n        // async        [ 'dot', [ 'name', 'require' ], 'async' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"async\") {\n            features.async = true;\n            currentIsAsyncFunction = true;\n        }\n        // preload        [ 'dot', [ 'name', 'require' ], 'preload' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"preload\") {\n            features.preload = true;\n            currentIsAsyncFunction = true;\n        }\n        // bundle        [ 'dot', [ 'name', 'require' ], 'bundle' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"bundle\") {\n            features.bundle = true;\n            currentIsAsyncFunction = true;\n        }\n        // stats        [ 'dot', [ 'name', 'require' ], 'stats' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"stats\") {\n            features.stats = true;\n        }\n        // stats_sendto [ 'dot', [ 'dot', [ 'name', 'require' ], 'stats' ], 'sendTo' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"sendTo\" && nameAst[1][0] === \"dot\" && nameAst[1][2] === \"stats\") {\n            features.stats_sendto = true;\n        }\n        // amd          [ 'dot', [ 'name', 'require' ], 'define' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"define\") {\n            features.amd = true;\n        }\n        // match        [ 'dot', [ 'name', 'require' ], 'define' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"match\") {\n            features.match = true;\n            currentIsMatch = true;\n        }\n        // promise           [ 'dot', [ 'call', [ 'dot', [Object], 'js' ], [ [Object] ] ], 'then' ]\n        if (nameAst[0] === \"dot\" && nameAst[2] === \"then\" && nameAst[1] && nameAst[1][0] === \"call\" ) {\n            features.promise = true;\n        }\n\n        if (requireAst[0] === \"call\") {\n            // parallel\n            if (currentIsAsyncFunction && requireAst[2][0] && requireAst[2][0] && requireAst[2][0][0] === \"array\") {\n                features.parallel = true;\n            }\n\n            // require() || require.js() || require.css() || require.match()\n            // require.async() || require.bundle() || require.preload()\n            if (currentIsMatch || currentIsAsyncFunction || requireAst[1][0] === \"name\") {\n                var argument = requireAst[2][0],\n                    parameters;\n\n                if (argument && (argument[0] === \"array\" || argument[0] === \"string\" || argument[0] === \"number\")) {\n                    if (argument[0] === \"array\") {\n                        parameters = argument[1];\n                    } else {\n                        parameters = [argument];\n                    }\n\n                    parameters.forEach(function (arg) {\n                        // uniq only\n                        if (depends.indexOf(arg[1]) === -1) {\n                            depends.push(arg[1]);\n                        }\n                    });\n                } else if (currentIsMatch && argument && argument[0] === \"regexp\") {\n                    depends.push(new RegExp(argument[1], argument[2]));\n                }\n            }\n        }\n    });\n\n    return {\n        features: features,\n        depends: depends\n    };\n};\n\n\nvar addExtraAmdDepends = function (ast, depends) {\n    if (!ast[1].length) return depends;\n    var lastDefine = findLastDefine(ast);\n\n    // find amd requirements\n    for (var i = 0, c = lastDefine[2].length, arg; i < c; i++) {\n        arg = lastDefine[2][i];\n        if (arg[0] === \"array\") {\n            for (var j = 0, c2 = arg[1].length, dependsName; j < c2; j++) {\n                dependsName = arg[1][j][1];\n                if (dependsName !== \"require\" && dependsName !== \"module\" && dependsName !== \"exports\") {\n                    if (depends.indexOf(dependsName) === -1) {\n                        depends.push(dependsName);\n                    }\n                }\n            }\n        }\n    }\n\n    return depends;\n};\n\n/**\n * @param {Object|String} extra\n * @returns {Array}\n */\nvar collect3partyDepends = function (extra) {\n    var result = [];\n\n    if (!extra) {\n        return result;\n    }\n\n    if (typeof extra !== 'object') {\n        // #81 Falsy warnings appears after adding 3-party modules\n        if (typeof extra === 'string') {\n            result.push(extra);\n        }\n    } else {\n        for (var requireVarName in extra) {\n            result.push(extra[requireVarName]);\n        }\n    }\n\n    return result;\n};\n\nvar analiseModuleContent = function (moduleOptions) {\n    var moduleDescriptor = {\n            type: \"\",\n            warns: [],\n            code: null,\n            originalCode: null,\n            depends: [],\n            features: {}\n        };\n\n    if (moduleOptions.is_shortcut) {\n        moduleDescriptor.type = \"shortcut\";\n        moduleDescriptor.features.shortcuts = true;\n\n        return moduleDescriptor;\n    }\n\n    if (!moduleOptions.is_exists) {\n        moduleDescriptor.type = \"not-exists\";\n\n        return moduleDescriptor;\n    }\n\n    var modulePath = [].concat(moduleOptions.path);\n\n    var code = modulePath.map(function (modulePath) {\n        return fs.readFileSync(modulePath, 'utf8');\n    }).join('\\n/* joined by builder */\\n');\n\n    var ast;\n\n    moduleDescriptor.code = code;\n    moduleDescriptor.originalCode = code;\n\n    try {\n        JSON.parse(code);\n        moduleDescriptor.type = \"json\";\n        return moduleDescriptor;\n    } catch (e) {}\n\n    try {\n        ast = parser.parse(code);\n    } catch (e) {\n        moduleDescriptor.type = \"string\";\n\n        var isOneOfModulesIsJs = modulePath.some(function (modulePath) {\n            return /.js$/.test(modulePath);\n        });\n\n        if (isOneOfModulesIsJs) {\n            moduleDescriptor.type = \"string\";\n            moduleDescriptor.warns\n                .push('File \"**' + modulePath.join('**\", \"**') + '**\" has extension **.js** and LMD detect an parse error. \\n' +\n                    e.toString().red +\n                    '\\nThis module will be string. Please check the source.');\n        }\n        return moduleDescriptor;\n    }\n\n    if (moduleOptions.is_third_party) {\n        moduleDescriptor.type = \"3-party\";\n    } else {\n        moduleDescriptor.type = getModuleType(ast);\n    }\n\n    // Apply type type hint\n    if (moduleOptions.type_hint) {\n        // Unexpected module type\n        if (!MODULE_TYPE_HINTS.hasOwnProperty(moduleOptions.type_hint)) {\n            moduleDescriptor.warns\n                .push('Unexpected module type hint `' + moduleOptions.type_hint + '` of module \"' + String(moduleOptions.name).green + '\". ' +\n                    'Only these types are supported: ' + Object.keys(MODULE_TYPE_HINTS).join(', '));\n        } else {\n            // Good type hint\n            moduleDescriptor.type = moduleOptions.type_hint;\n        }\n    }\n\n    moduleDescriptor.code = wrapModule(moduleDescriptor.code, moduleOptions, moduleDescriptor.type);\n\n    if (moduleDescriptor.type === '3-party') {\n        var extraRequires = []\n            .concat(collect3partyDepends(moduleOptions.extra_bind))\n            .concat(collect3partyDepends(moduleOptions.extra_require));\n\n        if (extraRequires.length && moduleOptions.is_sandbox) {\n            moduleDescriptor.warns\n                .push('Your module \"**' + modulePath.join('**\", \"**') + '**\" have to require() some dependencies, but it is sandboxed. ' +\n                'Remove sandbox flag to allow module require().');\n        }\n\n        Array.prototype.push.apply(moduleDescriptor.depends, extraRequires);\n    }\n\n    var requireExpressions = findRequireAccesses(ast, moduleDescriptor.type),\n        analyticsResult = findModuleRequirementsAndFeatures(requireExpressions);\n\n    moduleDescriptor.features = analyticsResult.features;\n    moduleDescriptor.depends = moduleDescriptor.depends.concat(analyticsResult.depends);\n\n    moduleDescriptor.depends = moduleDescriptor.depends.filter(function(item, index, array) {\n        return array.indexOf(item, index + 1) < 0;\n    });\n\n    if (moduleDescriptor.type === \"amd\") {\n        moduleDescriptor.features.amd = true;\n        moduleDescriptor.depends = addExtraAmdDepends(ast, moduleDescriptor.depends);\n    }\n\n    return moduleDescriptor;\n};\nexports.analiseModuleContent = analiseModuleContent;\n\nvar iterateModulesInfo = function (deepModulesInfo, iterator) {\n    Object.keys(deepModulesInfo).forEach(function (bundleName) {\n        var modules = deepModulesInfo[bundleName];\n        if (!modules) {\n            return;\n        }\n        Object.keys(modules).forEach(function (moduleName) {\n            iterator(modules[moduleName], moduleName, bundleName);\n        });\n    });\n};\nexports.iterateModulesInfo = iterateModulesInfo;\n\nvar groupModulesByBundles = function (config) {\n    var bundles = {};\n\n    bundles[ROOT_BUNDLE_ID] = config.modules || {};\n    Object.keys(config.bundles || {}).forEach(function (bundleName) {\n        bundles[bundleName] = config.bundles[bundleName].modules;\n    });\n\n    return bundles;\n};\nexports.groupModulesByBundles = groupModulesByBundles;\n\nvar collectFlagsWarnings = function (config, deepModulesInfo) {\n    var featureWarnings = {},\n        result = [],\n        is_using_shortcuts = false,\n        is_using_amd = false;\n\n    // aggregate usage\n    iterateModulesInfo(deepModulesInfo, function (module, moduleName, bundleName) {\n        if (module.type === \"amd\") {\n            is_using_amd = true;\n        }\n        if (module.type === \"shortcut\") {\n            is_using_shortcuts = true;\n        }\n        var features = module.features;\n        for (var featureName in features) {\n            if (typeof config[featureName] === \"undefined\" || config[featureName] === false) {\n                if (!featureWarnings[featureName]) {\n                    featureWarnings[featureName] = [];\n                }\n                if (bundleName === ROOT_BUNDLE_ID) {\n                    featureWarnings[featureName].push(moduleName);\n                } else {\n                    featureWarnings[featureName].push(bundleName + SUB_BUNDLE_SEPARATOR + moduleName);\n                }\n            }\n        }\n    });\n\n    for (var featureName in featureWarnings) {\n        result.push(\"Required \" + (\"\\\"\" + featureName + \"\\\"\").green + \": \" + \"true\".green +\n                    \". Some of your modules (\" + (featureWarnings[featureName].join(', ')).cyan + \") are uses feature \" + (\"`\" + featureName + \"`\").green + \", \" +\n                    \"but it disable in this build.\");\n    }\n\n    if (!is_using_shortcuts && config.shortcuts) {\n        result.push('Config flag ' + '`shortcuts`'.green + ' is enabled, but there is no shortcuts in your package. ' +\n                  'Disable that flag to optimize your package.');\n    }\n\n    if (!is_using_amd && config.amd) {\n        result.push('Config flag ' + '`amd`'.green + ' is enabled, but there is no AMD Modules in your package. ' +\n                  'Disable that flag to optimize your package.');\n    }\n\n    if (config.stats_coverage && (config.cache || config.cache_async)) {\n        result.push('LMD will cache your modules under code coverage. You can disable ' + '`cache`'.green + ' and ' + '`cache_async`'.green + ' flags.');\n    }\n\n    if (config.async_plain && config.async_plainonly) {\n        result.push('You are using both config flags ' + '`async_plain`'.green + ' and ' + '`async_plainonly`'.green + '. Disable one to optimise your source.');\n    }\n\n    if (!config.stats_coverage && config.stats_coverage_async) {\n        result.push('You are using ' + '`stats_coverage_async`'.green + ' without ' + '`stats_coverage`'.green + '. Enable ' + '`stats_coverage`'.green + ' flag.');\n    }\n\n    if (!config.async && config.stats_coverage_async) {\n        result.push('You are using ' + '`stats_coverage_async`'.green + ' but not using ' + '`async`'.green + '. Disable ' + '`stats_coverage_async`'.green + ' flag.');\n    }\n\n    if ('promise' in config && typeof config.promise !== \"string\") {\n        result.push('`promise`'.green + ' should be a string pointing to the deferred factory function. eg ' + '\"promise\"'.green + ': ' + '\"$.Deferred\"'.green);\n    }\n\n    if ('banner' in config) {\n        if (typeof config.banner !== 'string') {\n            result.push('`banner`'.green + ' should be a string');\n        } else {\n            // Banner should not contain any javascript. Checking it.\n            try {\n                var ast = parser.parse(config.banner);\n                if (ast[1].length !== 0) {\n                    result.push('`banner`'.green + ' should be a JavaScript comment. Please remove any executable JavaScript from ' + '`banner`'.green + '.');\n                }\n            } catch (e) {\n                result.push('Something is wrong with your ' + '`banner`'.green + ', please check it');\n            }\n        }\n    }\n\n    var warnings = {\n        globals: 'Some of your modules are undeclared (register them as ' + '\"name\"'.green + ': ' + '\"@shortcut\"'.green + ' or use directly if they are globals):',\n        modules: 'Some of our modules are probably off-package (you can register them as ' + '\"name\"'.green + ': ' + '\"@shortcut\"'.green + '):',\n        unused: 'Some of your modules are declared but not used:'\n    };\n\n    var suspiciousNames = getSuspiciousNames(config, deepModulesInfo);\n    Object.keys(warnings).forEach(function (warningName) {\n        if (suspiciousNames[warningName].length) {\n            result.push(warnings[warningName]);\n            suspiciousNames[warningName].forEach(function (name) {\n                result.push('    - ' + name.toString().yellow);\n            });\n            result.push('');\n        }\n    });\n\n    var missedBundles = Object.keys(config.bundles || {}).reduce(function (missedBundles, name) {\n        if (config.bundles[name] instanceof Error) {\n            missedBundles.push({\n                name: name,\n                path: config.bundles[name].message\n            });\n        }\n        return missedBundles;\n    }, []);\n\n    if (missedBundles.length) {\n        result.push('Some bundles are missing:');\n        missedBundles.forEach(function (info) {\n            result.push('    - \"' + String(info.name).cyan + '\": \"' + String(info.path).red + '\"');\n        });\n    }\n\n    var conflictModules = Object.keys(suspiciousNames.conflicts);\n    if (conflictModules.length) {\n        result.push('Some module names are conflict. Modules from bundles will be ignored.');\n        conflictModules.forEach(function (moduleName) {\n            var names = suspiciousNames.conflicts[moduleName].sort().map(function (bundlename) {\n                if (bundlename === ROOT_BUNDLE_ID) {\n                    return 'main';\n                }\n\n                return bundlename.yellow;\n            });\n\n            result.push('    - ' + moduleName.toString().yellow + ' is defined in many bundles: ' + names.join(', '));\n        });\n        result.push('');\n    }\n\n    // User plugins warnings\n    var plugins = config.plugins,\n        pluginInfo,\n        badPlugins = [];\n\n    for (var pluginName in plugins) {\n        pluginInfo = plugins[pluginName];\n        if (!pluginInfo.isOk) {\n            badPlugins.push(pluginName.cyan);\n        }\n        if (pluginInfo.isConflict) {\n            result.push('User plugin \"' + pluginName.toString().cyan + '\": \"' + pluginInfo.originalPath.red + '\" should not be named as internal plugin.');\n            continue;\n        }\n        if (!pluginInfo.isExists) {\n            result.push('User plugin \"' + pluginName.toString().cyan + '\": \"' + pluginInfo.originalPath.red + '\" (' + pluginInfo.path.red + ') is not exists.');\n            continue;\n        }\n        if (!pluginInfo.isValid) {\n            result.push('User plugin \"' + pluginName.toString().cyan + '\": \"' + pluginInfo.originalPath.red + '\" is not valid. ' +\n                'It should be IIFE eg (function(sb){var your_code;}(sandbox));');\n        }\n    }\n\n    if (badPlugins.length) {\n        result.push('User plugins \"' + badPlugins.join('\", \"') + '\" will be excluded from this build.');\n    }\n\n    return result;\n};\nexports.collectFlagsWarnings = collectFlagsWarnings;\n\nvar collectFlagsNotifications = function (config) {\n    var result = [], dependsOf;\n    if (config.plugins_depends) {\n        for (var dependsName in config.plugins_depends) {\n            dependsOf = config.plugins_depends[dependsName];\n\n            result.push('Extra plugin was added ' + ('\"' + dependsName + '\"').green + ': ' + 'true'.green + '. This is depends of ' + dependsOf.join(', ').cyan + '.');\n        }\n    }\n\n    return result;\n};\nexports.collectFlagsNotifications = collectFlagsNotifications;\n\nfunction getGlobals(config) {\n    var result = {},\n        names = ['GLOBALS'];\n\n    if (config.node) {\n        names.push('NODE_GLOBALS');\n    }\n\n    if (config.worker) {\n        names.push('WORKER_GLOBALS');\n    }\n\n    names.forEach(function (name) {\n        var globalNames = exports[name];\n        for (var name in globalNames) {\n            result[name] = globalNames[name];\n        }\n    });\n\n    return result;\n}\nexports.getGlobals = getGlobals;\n\nfunction discoverModuleType(moduleName, modulesNames, globalsNames) {\n    if (moduleName instanceof RegExp) {\n        return 'regexp';\n    }\n\n    if (modulesNames.indexOf(moduleName) != -1) {\n        return 'in-package';\n    }\n\n    if (typeof globalsNames[moduleName] !== \"undefined\") {\n        return 'global';\n    }\n\n    if (/\\.[a-z]{1,}$/.test(moduleName)) {\n        return 'off-package?';\n    }\n\n    return 'global?';\n}\nexports.discoverModuleType = discoverModuleType;\n\nfunction getSuspiciousNames(config, deepModulesInfo) {\n    var globalsNames = getGlobals(config),\n        suspiciousNames = {\n            globals: [],\n            modules: [],\n            unused: [],\n            conflicts: {}\n        },\n        suspiciousNamesIndex = {\n            globals: {},\n            modules: {},\n            unused: {}\n        };\n\n    // list of RegExp that require.match() is using\n    var matchRegExpList = [];\n\n    var bundles = groupModulesByBundles(config);\n\n    // all module names\n    var modulesNames = [];\n    iterateModulesInfo(bundles, function (module, name, bundleName) {\n        modulesNames.push(name);\n    });\n\n    function isMainModuleOf(name, bundleName) {\n        if (bundleName === ROOT_BUNDLE_ID) {\n            return config.main === name;\n        }\n        if (config.bundles[bundleName]) {\n            return config.bundles[bundleName].main === name;\n        }\n        return false;\n    }\n\n    iterateModulesInfo(bundles, function (module, name, bundleName) {\n        if (!suspiciousNamesIndex.unused.hasOwnProperty(name)) {\n            suspiciousNamesIndex.unused[name] = false;\n        }\n\n        // count names across bundles\n        if (!suspiciousNames.conflicts[name]) {\n            suspiciousNames.conflicts[name] = [];\n        }\n        // do not count main modules they can't conflict\n        if (!isMainModuleOf(name, bundleName)) {\n            suspiciousNames.conflicts[name].push(bundleName);\n        }\n\n        var depends = deepModulesInfo[bundleName][name].depends;\n        depends.forEach(function (name) {\n            var moduleType = discoverModuleType(name, modulesNames, globalsNames);\n\n            // Add this regexp list to use later\n            if (moduleType === 'regexp') {\n                matchRegExpList.push(name);\n                return;\n            }\n\n            // skip special LMD names\n            if (typeof exports.LMD_GLOBALS[name] !== \"undefined\") {\n                return;\n            }\n\n            if (moduleType === 'global?' && !suspiciousNamesIndex.globals[name]) {\n                suspiciousNamesIndex.globals[name] = true;\n                suspiciousNames.globals.push(name);\n            }\n\n            if (moduleType === 'off-package?' && !suspiciousNamesIndex.modules[name]) {\n                suspiciousNamesIndex.modules[name] = true;\n                suspiciousNames.modules.push(name);\n            }\n\n            suspiciousNamesIndex.unused[name] = true;\n        });\n    });\n\n    // add unused\n    iterateModulesInfo(bundles, function (module, name, bundleName) {\n        if (config.main === name) {\n            return;\n        }\n        if (!suspiciousNamesIndex.unused[name]) {\n            // If one of module.match() regex matches name - module is used\n            // do not add it to unused list\n            var isMatch = matchRegExpList.some(function (regexp) {\n                return regexp.test(name);\n            });\n\n            if (!isMatch) {\n                suspiciousNames.unused.push(name);\n            }\n        }\n    });\n\n    // Cleanup module names without conflicts across bundles\n    var conflicts = suspiciousNames.conflicts;\n    suspiciousNames.conflicts = Object.keys(conflicts).reduce(function (result, moduleName) {\n        if (conflicts[moduleName].length > 1) {\n            result[moduleName] = conflicts[moduleName];\n        }\n\n        return result;\n    }, {});\n\n    return suspiciousNames;\n}\nexports.getSuspiciousNames = getSuspiciousNames;\n\n/**\n * Checks module type\n *\n * @param {Object|String} code module AST or module Content\n *\n * @return {String} df|fe|plain|amd\n */\nfunction getModuleType (code) {\n    var ast;\n\n    if (typeof code === \"object\") {\n        ast = code;\n    } else {\n        try {\n            JSON.parse(code);\n            return \"json\";\n        } catch (e) {}\n\n        try {\n            ast = parser.parse(code);\n        } catch (e) {\n            return \"string\";\n        }\n    }\n\n    // Empty module\n    if (ast.length === 2 && !ast[1].length && ast[0] === 'toplevel') return \"plain\";\n\n    // [\"toplevel\",[[\"defun\",\"depA\",[\"require\"],[]]]]\n    if (ast && ast.length === 2 &&\n        ast[1] && ast[1].length === 1 &&\n        ast[1][0][0] === \"defun\"\n        ) {\n        return \"fd\";\n    }\n\n    // [\"toplevel\",[[\"stat\",[\"function\",null,[\"require\"],[]]]]]\n    if (ast && ast.length === 2 &&\n        ast[1] && ast[1].length === 1 &&\n        ast[1][0][0] === \"stat\" &&\n        ast[1][0][1] &&\n        ast[1][0][1][0] === \"function\"\n        ) {\n        return \"fe\";\n    }\n\n    if (ast) {\n        var isAmd = ast[1].every(function (ast) {\n            return ast[0] === \"stat\" &&\n                ast[1][0] === \"call\" &&\n                ast[1][1][0] === \"name\" &&\n                ast[1][1][1] === \"define\";\n        });\n\n        if (isAmd) {\n            return \"amd\";\n        }\n    }\n\n    return \"plain\";\n}\n\n/**\n * @param {String} lmdDir\n * @param {String} shortName\n *\n * @returns {String|undefined}\n */\nfunction getModuleFileByShortName(lmdDir, shortName) {\n    var files;\n\n    try {\n        files = fs.readdirSync(lmdDir);\n    } catch (e) {\n        return void 0;\n    }\n\n    for (var i = 0, c = files.length, fileName; i < c; i++) {\n        fileName = files[i];\n        var fileExtension = (fileName.match(reLmdFile) || 0)[0];\n        if (fileExtension && path.basename(fileName, fileExtension) === shortName) {\n            return fileName;\n        }\n    }\n}\nexports.getModuleFileByShortName = getModuleFileByShortName;\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/lib/lmd_writer.js":"var fs = require('fs'),\n    Stream = require('stream'),\n    path = require('path'),\n    LogWriter = require(__dirname + '/../bin/cli_messages.js').LogWriter;\n\nvar LmdWriter = function (buildResult) {\n    this.source = buildResult;\n    this.cwd = process.cwd();\n    this.cli = new LogWriter(process.stdout);\n    this.pendingStreams = 0;\n    this.callback = null;\n};\n\nmodule.exports = LmdWriter;\n\n/**\n * Changes current work dir\n *\n * @param {String} cwd\n *\n * @return {LmdWriter}\n */\nLmdWriter.prototype.relativeTo = function (cwd) {\n    this.cwd = cwd;\n\n    return this;\n};\n\n/**\n * Changes current log interface\n *\n * @param {LogWriter} cli\n *\n * @return {LmdWriter}\n */\nLmdWriter.prototype.logTo = function (cli) {\n    if (!(cli instanceof LogWriter)) {\n        throw new TypeError('cli should be instance of LogWriter');\n    }\n\n    this.cli = cli;\n\n    return this;\n};\n\n/**\n * Resolves paths relative to cwd\n *\n * @param {Object} buildConfig\n * @private\n */\nLmdWriter.prototype._resolvePaths = function (buildConfig) {\n    var cwd = this.cwd,\n        configs = path.join(cwd, '.lmd'),\n        root = path.resolve(configs, buildConfig.root || ''),\n        sourceMap = buildConfig.sourcemap ? path.resolve(root, buildConfig.sourcemap) : null,\n        source = buildConfig.output ? path.resolve(root, buildConfig.output) : null,\n        style = buildConfig.styles_output ? path.resolve(root, buildConfig.styles_output) : null;\n\n    return {\n        configs: configs,\n        root: root,\n        sourceMap: sourceMap,\n        source: source,\n        style: style\n    };\n};\n\nLmdWriter.prototype._isCanWriteStream = function (stream, fileName) {\n    return fileName && stream && stream.readable;\n};\n\nLmdWriter.prototype._pipeStreamToFile = function (stream, fileName) {\n    if (this._isCanWriteStream(stream, fileName)) {\n        var writer = fs.createWriteStream(fileName, {\n            flags: \"w\",\n            encoding: \"utf8\",\n            mode: 0666\n        });\n\n        this._waitFor(writer, 'close');\n\n        stream.pipe(writer);\n    }\n};\n\nLmdWriter.prototype._logResult = function (stream, fileName, resourceName) {\n    var cli = this.cli;\n\n    if (this._isCanWriteStream(stream, fileName)) {\n        stream.once('end', function () {\n            cli.ok('Writing ' + resourceName + ' to ' + fileName.green);\n        });\n    }\n};\n\nLmdWriter.prototype._writeStreamsTo = function (stream, paths, resourceName) {\n    this._logResult(stream, paths.source, 'LMD ' + resourceName);\n    this._pipeStreamToFile(stream, paths.source);\n\n    this._logResult(stream.sourceMap, paths.sourceMap, 'Source Map of ' + resourceName);\n    this._pipeStreamToFile(stream.sourceMap, paths.sourceMap);\n\n    this._logResult(stream.style, paths.style, 'Style of ' + resourceName);\n    this._pipeStreamToFile(stream.style, paths.style);\n};\n\nLmdWriter.prototype._streamEnd = function () {\n    var self = this;\n\n    this.pendingStreams--;\n    if (this.callback && this.pendingStreams <= 0) {\n        // setImmediate\n        setTimeout(function () {\n            self.callback();\n        }, 0);\n    }\n};\n\nLmdWriter.prototype._waitFor = function (stream, event) {\n    var self = this;\n\n    if (!stream) {\n        return;\n    }\n\n    this.pendingStreams++;\n    stream.once(event, function () {\n        self._streamEnd();\n    });\n};\n\nLmdWriter.prototype._onAllEnd = function (callback) {\n    this.callback = callback;\n\n    var self = this,\n        bundles = this.source.bundles;\n\n    Object.keys(bundles)\n        .map(function (bundleName) {\n            return bundles[bundleName];\n        })\n        .concat([this.source, this.source.log])\n        .forEach(function (stream) {\n            if (!stream.readable) {\n                return;\n            }\n\n            self._waitFor(stream, 'end');\n        });\n};\n\n/**\n * Writes all build data\n */\nLmdWriter.prototype.writeAll = function (callback) {\n    var cli = this.cli,\n        self = this,\n        source = this.source,\n\n        buildConfig = this.source.buildConfig,\n        configFile = this.source.configFile,\n        buildName = path.basename(configFile).split('.lmd')[0],\n\n        paths = this._resolvePaths(buildConfig),\n\n        isPrintToStdout = paths.source === null,\n        isCanLog = buildConfig.log && !isPrintToStdout;\n\n    // fatal error\n    if (source.readable === false && isCanLog) {\n        source.log.pipe(cli.stream);\n        callback('fatal');\n        return;\n    }\n\n    if (isPrintToStdout) {\n        source.pipe(cli.stream);\n        callback(null);\n        return;\n    }\n\n    this._onAllEnd(callback);\n\n    if (isCanLog) {\n        var versionString = buildConfig.version ? ' - version ' + buildConfig.version.toString().cyan : '';\n        cli.ok('Building `' + buildName.green +  '` (' + ('.lmd/' + buildName + '.lmd.js(on)').green + ')' + versionString);\n        if (buildConfig.mixins && buildConfig.mixins.length) {\n            cli.ok('Extra mixins ' + buildConfig.mixins.map(function (mixinName) {\n                return mixinName.green\n            }).join(', '));\n        }\n    }\n\n    // Print package\n    this._writeStreamsTo(source, paths, 'Package');\n\n    // Print bundles\n    var bundles = buildConfig.bundles;\n    Object.keys(bundles).forEach(function (bundleName) {\n        var stream = source.bundles[bundleName],\n            paths = self._resolvePaths(bundles[bundleName]);\n\n        self._writeStreamsTo(stream, paths, 'Bundle ' + bundleName.green);\n    });\n\n    // Print warnings log\n    if (isCanLog) {\n        source.log.pipe(cli.stream);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/cli_messages.js":"require('colors');\n\nvar LogWriter = function (stream) {\n    this.stream = stream;\n};\n\nLogWriter.prototype.log = function (message) {\n    this.stream.write(message + '\\n');\n};\n\nLogWriter.prototype.ok = function (message) {\n    this.log('info'.green + ':    ' + message);\n};\n\nLogWriter.prototype.warn = function (message) {\n    this.log('warn'.yellow + ':    ' + message);\n};\n\nLogWriter.prototype.error = function (message) {\n    this.log('ERRO'.red.inverse + ':    ' + message);\n};\n\nLogWriter.prototype.help = function (content, errorMessage) {\n    var help = [\n        '',\n        'LMD Builder',\n        ''\n    ];\n\n    help = help.concat(content);\n\n    if (errorMessage) {\n        help = help.concat([errorMessage.red, '']);\n    }\n\n    help = help.map(function (line) {\n        return 'help'.cyan + ':    ' + line;\n    }).join('\\n');\n\n    this.log(help);\n};\n\nexports.LogWriter = LogWriter;\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions.js":"var shell = process.env.SHELL && process.env.SHELL.match(/\\/([^\\/]+)$/)[1] || 'bash';\n\nexports.actions = {\n    init: 'Initializes LMD for project',\n    create: 'To create new LMD config',\n    update: 'Updates existed LMD config',\n    list: 'To see LMD packages list',\n    build: 'To build LMD package',\n    watch: 'To start/stop LMD package watcher',\n    server: 'To start/stop LMD stats server',\n    info: 'To see LMD extended package/build info',\n    completion: '$ lmd completion >> ~/.' + shell + 'rc'\n};\n\nexports.aliases = {\n    'init': 'init',\n\n    'create': 'create',\n    'new': 'create',\n\n    'update': 'update',\n    'up': 'update',\n\n    'list': 'list',\n    'ls': 'list',\n\n    'build': 'build',\n    'make': 'build',\n\n    'watch': 'watch',\n\n    'server': 'server',\n    'serv': 'server',\n    'stats': 'server',\n\n    'info': 'info',\n    'dry': 'info',\n    'dry-run': 'info',\n\n    'completion': 'completion'\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd.js":"/**\n * LMD\n *\n * @author  Mikhail Davydov\n * @licence MIT\n */\nvar path = require('path');\n\n// Supress path.existsSync is now called `fs.existsSync`.\npath.existsSync = require('fs').existsSync;\npath.exists = require('fs').exists;\n\nvar fs = require('fs'),\n    cli = require(__dirname + '/cli_messages.js'),\n    actions = require(__dirname + '/lmd_actions.js');\n\nrequire('colors');\n\nvar allowedActions = actions.actions;\nvar actionsAliases = actions.aliases;\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd <action> <argument> <param1> <param2> ...',\n        '',\n\n        'Actions:'.bold.white.underline,\n        ''\n    ];\n\n    var actions_help = Object.keys(allowedActions).reduce(function (result, action) {\n        return result.concat([allowedActions[action].cyan, '  lmd ' + action, '']);\n    }, []);\n\n    help = help.concat(actions_help);\n\n    cli.help(help, errorMessage);\n}\n\nfunction init(stdout, argv, cwd) {\n    var options = require('optimist').parse(argv),\n        action = argv[2],\n        logWriter = new cli.LogWriter(stdout);\n\n    if (argv.length === 3 && (options.v || options.version)) {\n        stdout.write(require(__dirname + '/../package.json').version + '\\n');\n\n    } else if (!actionsAliases.hasOwnProperty(action)) {\n        if (argv.length >= 4) {\n            require(__dirname + '/lmd_actions/old.js')(logWriter, argv.slice(2), cwd);\n        } else {\n            printHelp(logWriter);\n        }\n\n    } else {\n        require(__dirname + '/lmd_actions/' + actionsAliases[action] + '.js')(logWriter, argv.slice(2), cwd);\n\n    }\n}\nexports.init = init;\n\n// if !main\nif (!module.parent || (module.parent && module.parent.filename.match(/\\/lmd\\/bin\\/lmd$|\\\\lmd\\\\bin\\\\lmd$/))) {\n    init(process.stdout, process.argv, process.cwd());\n}","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_stats.js":"/**\n * LMD\n *\n * @author  Mikhail Davydov\n * @licence MIT\n */\n\n\nnew (require(__dirname + '/../stats_server/index.js'))(process.argv.join(' '));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/stats_server/index.js":"/**\n * LMD Stats Server\n *\n * @author  Mikhail Davydov\n * @licence MIT\n */\nvar fs = require('fs'),\n    path = require('path'),\n    express = require(\"express\"),\n    common = require(__dirname + '/../lib/lmd_common.js'),\n    assembleLmdConfig = common.assembleLmdConfig,\n    flagToOptionNameMap = common.LMD_PLUGINS;\n\nrequire('colors');\n\n/**\n *\n * @constructor\n *\n * @example\n *\n * new LmdStatsServer({\n *    address: '0.0.0.0',\n *    port: 8081,\n *    config: '../examples/mock_chat/js/lmd/index.lmd.json',\n *    log: './logs/',\n *    www: '../examples/mock_chat/'\n * });\n */\nfunction LmdStatsServer(data) {\n    var args = this.parseData(data);\n\n    this.address = args.address || args.a || '0.0.0.0';\n    this.port = args.port || args.p || 8081;\n\n    this.adminAddress = args['admin-address'] || args.aa || this.address;\n    this.adminPort = args['admin-port'] || args.ap || this.port;\n\n    this.isSameAdresses = this.address === this.adminAddress &&\n                          this.port === this.adminPort;\n\n    this.configFile = args.config || args.c;\n    this.logDir = args.log || args.l;\n    this.wwwDir = args.www || args.wd;\n\n    if (!this.logDir || !this.wwwDir) {\n        throw new Error('Log dir and www dir must be specified');\n    }\n\n    if (!this.configFile) {\n        throw new Error('Config file is required');\n    }\n\n    this.logDir = fs.realpathSync(this.logDir);\n    this.wwwDir = fs.realpathSync(this.wwwDir);\n    this.configFile = fs.realpathSync(this.configFile);\n    this.configDir = path.dirname(this.configFile);\n\n    this.config = assembleLmdConfig(this.configFile, Object.keys(flagToOptionNameMap));\n\n    this.modules = this.config.modules;\n\n    // 2.0 -> 3.0 migration\n    this.app = typeof express === \"function\" ? express() : express.createServer();\n\n    if (this.isSameAdresses) {\n        this.adminApp = this.app;\n        this.app.use(express.bodyParser());\n        console.log('info'.green +  ':    Admin and log server are on ' + this.address.green + ':' + this.port.toString().green);\n    } else {\n        this.app.use(express.bodyParser());\n        // 2.0 -> 3.0 migration\n        this.adminApp = typeof express === \"function\" ? express() : express.createServer();\n        this.adminApp.use(express.bodyParser());\n        this.adminApp.listen(this.adminPort, this.adminAddress);\n        console.log('info'.green +  ':    Admin server is on ' + this.adminAddress.green + ':' + this.adminPort.toString().green);\n        console.log('info'.green +  ':    Log server is on ' + this.address.green + ':' + this.port.toString().green);\n    }\n\n    console.log('info'.green +  ':    Logs dir: ' + this.logDir.green);\n    console.log('info'.green +  ':    Package root dir: ' + this.wwwDir.green);\n    console.log('info'.green +  ':    LMD Config: ' + this.configFile.green);\n\n    this.app.listen(this.port, this.address);\n    require(__dirname + '/lib/admin.js').attachTo(this.adminApp, this.logDir, this.wwwDir, this.config, this.modules);\n    require(__dirname + '/lib/log.js').attachTo(this.app, this.logDir);\n\n    console.log('info'.green +  ':    Hit Ctrl+C to stop');\n}\n\n/**\n * Simple argv parser\n *\n * @see https://gist.github.com/1497865\n *\n * @param {String} a an argv string\n *\n * @returns {Object}\n */\nLmdStatsServer.prototype.parseArgv = function (a,b,c,d) {\n    c={};for(a=a.split(/\\s*\\B[-]+([\\w-]+)[\\s=]*/),d=1;b=a[d++];c[b]=a[d++]||!0);return c\n};\n\n/**\n * @param {String|Object} data\n * @return {Object}\n */\nLmdStatsServer.prototype.parseData = function (data) {\n    if (typeof data === \"object\") {\n        return data;\n    }\n\n    return this.parseArgv(data);\n};\n\nmodule.exports = LmdStatsServer;\n\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/lmd_initializer.js":"/**\n * This file is not part of lmd.js.\n *\n * This is localStorage loader with script fallback.\n *\n * @see /README.md near \"Local Storage cache\" for more info\n * @see live example /lmd/examples/mock_chat/index_cache.html near \"lmd-initializer\"\n *\n * How it works:\n *\n *   - if browser not support localStorage - it loads fallback script\n *   - if support localStorage and cache exists\n *     - and version is not expired - it start application from cache\n *     - version expired - it wipes cache and it loads fallback script\n *   - if no cache - it loads fallback script\n */\n(function (global, document, scriptId, prefix, getAttribute, removeItem) {\n    var globalEval = function (code) {\n            return global.Function('return ' + code)();\n        },\n        scriptElement = document.getElementById(scriptId),\n        actualVersion = scriptElement[getAttribute](prefix + 'version'),\n        storageKey = scriptElement[getAttribute](prefix + 'key'),\n        fallbackUrl = scriptElement[getAttribute](prefix + 'src'),\n        ls = global.localStorage,\n        // lmd:%version%:%module_name%\n        rx = new RegExp('^' + storageKey + ':([^:]+):(.*)$'),\n\n        script, json, head, item, main, lmd, match;\n\n    if (ls) { // if localStorage then JSON too\n        item = ls[storageKey];\n        if (item) {\n            try {\n                json = global.JSON.parse(item);\n                if (json && json.options.version === actualVersion) {\n                    // exec cached app\n                    // Note: do not pass version!\n                    main = globalEval(json.main);\n                    lmd = globalEval(json.lmd);\n                }\n\n                // cache async modules\n                for (storageKey in ls) {\n                    match = storageKey.match(rx);\n                    // version match\n                    if (match) {\n                        // version match?\n                        if (match[1] === actualVersion) {\n                            // module_name = module_value\n                            json.modules[match[2]] = global.JSON.parse(ls[storageKey]);\n                        } else {\n                            ls[removeItem](storageKey);\n                        }\n                    }\n                }\n            } catch (e) {}\n            if (lmd && main) {\n                // do not catch module's errors\n                lmd(global, main, json.modules, json.modules_options, json.options);\n                return;\n            }\n            // if error or version do not match - wipe cache\n            ls[removeItem](storageKey);\n            for (storageKey in ls) {\n                if (rx.test(storageKey)) {\n                    ls[removeItem](storageKey);\n                }\n            }\n        }\n    }\n\n    // fallback\n    head = document.getElementsByTagName('head')[0];\n    script = document.createElement('script');\n    script.setAttribute('src', fallbackUrl);\n    head.insertBefore(script, head.firstChild);\n}(this, this.document, 'lmd-initializer', 'data-', 'getAttribute' , 'removeItem'));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/completion.js":"var fs = require('fs'),\n    path = require('path');\n\nfunction dumpScript() {\n    console.log(fs.readFileSync(path.join(__dirname, '..', 'lmd_completion.sh'), 'utf8'));\n}\n\nmodule.exports = function (cli, argv, cwd) {\n\n    if (typeof process.env.COMP_CWORD === \"undefined\" ||\n        typeof process.env.COMP_LINE === \"undefined\" ||\n        typeof process.env.COMP_POINT === \"undefined\" ||\n        argv.length === 1 && argv[0] === \"completion\" ) {\n\n        return dumpScript();\n    }\n\n    var index = --process.env.COMP_CWORD,\n        args = argv.slice(3),\n        action = args[0];\n\n    var actions = require(path.join(__dirname, '..', 'lmd_actions.js'));\n\n    if (index === 0) {\n        cli.log(Object.keys(actions.actions).join('\\n'));\n    } else if (args[0] !== \"completion\") {\n        var module = require(path.join(__dirname , actions.aliases[action] + '.js'));\n\n        if (typeof module.completion === \"function\") {\n            module.completion(cli, argv, cwd, {\n                index: index,\n                args: args,\n                action: action,\n                word: args[index]\n            });\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/create.js":"require('colors');\n\nvar fs = require('fs'),\n    path = require('path'),\n    optimist = require('optimist'),\n    info = require(__dirname + '/info.js'),\n    init = require(__dirname + '/init.js'),\n    common = require(__dirname + '/../../lib/lmd_common.js'),\n    resolveName = common.getModuleFileByShortName;\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd create ' + '<build_name>'.blue + ' [' + '<parent_build_name>'.cyan + '] [' + '<flags>'.green + ']',\n        '',\n\n        'Example:'.bold.white.underline,\n        '',\n\n        '  lmd create ' + 'development'.blue,\n        '  lmd create ' + 'development'.blue + ' --no-pack --async --js --css'.green,\n        '  lmd create ' + 'production'.blue + ' development'.cyan + ' --pack --ie'.green,\n        '  lmd create ' + 'testing'.blue + ' production'.cyan,\n        ''\n    ];\n\n    cli.help(help, errorMessage);\n}\n\nfunction checkFile(cwd, name) {\n    var isGoodFileName = !!name.match(/\\/|\\\\|^\\./);\n    if (isGoodFileName) {\n        return 'bad build name `' + name + '`';\n    }\n    //var lmdConfig = path.join(cwd, '.lmd', name + '.lmd.json');\n    var lmdDir = path.join(cwd, '.lmd'),\n        lmdFile = resolveName(lmdDir, name);\n\n    if (!lmdFile) {\n        return false;\n    }\n    var lmdConfig = path.join(lmdDir, lmdFile);\n    if (fs.existsSync(lmdConfig)) {\n        if (fs.statSync(lmdConfig).isFile()) {\n            // already exists\n            return true;\n        }\n        return lmdConfig + ' is a dir';\n    }\n\n    // not exists\n    return false;\n}\n\nfunction template(buildName, parentConfig, options) {\n    var json = {};\n    json.name = buildName + \" build\";\n    json.root = \"../\";\n    json.output = buildName + \".lmd.js\";\n    if (parentConfig) {\n        json.extends = parentConfig;\n    }\n    json.modules = {};\n\n    json.main = \"main\";\n\n    if (options) {\n        json = common.deepDestructableMerge(json, options);\n    }\n\n    return JSON.stringify(json, null, '    ');\n}\n\nfunction createBuild(cwd, buildName, parentBuild, options) {\n    var lmdDir = path.join(cwd, '.lmd'),\n        lmdFile = buildName + '.lmd.json',\n        lmdConfig = path.join(lmdDir, lmdFile),\n\n        parentConfig = parentBuild ? resolveName(lmdDir, parentBuild) : null;\n\n    fs.writeFileSync(lmdConfig, template(buildName, parentConfig, options), 'utf8');\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    argv = optimist.parse(argv);\n\n    var status,\n        buildName = argv._[1],\n        parentBuild = argv._[2];\n\n    delete argv._;\n    delete argv.$0;\n\n    if (!init.check(cli, cwd)) {\n        return;\n    }\n\n    if (!buildName) {\n        printHelp(cli);\n        return;\n    }\n\n    status = checkFile(cwd, buildName);\n\n    if (status) {\n        printHelp(cli, status === true ? 'build `' + buildName + '` is already exists' : status);\n        return;\n    }\n\n    if (parentBuild) {\n        status = checkFile(cwd, parentBuild);\n\n        if (status !== true) {\n            printHelp(cli, status === false ? 'parent build `' + parentBuild + '` is not exists' : status);\n            return;\n        }\n    }\n\n    cli.ok('');\n    cli.ok('Build `' + buildName.green +  '` (' + ('.lmd/' + buildName + '.lmd.json').green + ') created');\n    cli.ok('');\n\n    var extraFlags = Object.keys(argv);\n\n    if (extraFlags.length) {\n        cli.ok('These options are also added'.cyan.bold + ':');\n        cli.ok('');\n\n        var offset = extraFlags.reduce(function (longest, current) {\n            return current.length > longest ? current.length : longest;\n        }, 0);\n\n        offset += 3;\n\n        extraFlags.forEach(function (flagName) {\n            var spaces = new Array(offset - flagName.length).join(' ');\n\n            cli.ok('  ' + flagName.green + spaces + JSON.stringify(argv[flagName]));\n        });\n        cli.ok('');\n    }\n\n    createBuild(cwd, buildName, parentBuild, argv);\n};\n\nmodule.exports.checkFile = checkFile;\n\nmodule.exports.completion = function (cli, argv, cwd, completionOptions) {\n    // module name completion\n    if (completionOptions.index === 1) {\n        return;\n    }\n\n    // <flags> & <options>\n    if (completionOptions.index > 1) {\n        var flagsOptions = info.getCompletionOptions({});\n\n        return cli.log(flagsOptions.join('\\n'));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/info.js":"require('colors');\n\nvar path = require('path'),\n    fs = require('fs'),\n    init = require(__dirname + '/init.js'),\n    create = require(__dirname + '/create.js'),\n    list = require(__dirname + '/list.js'),\n    common = require(__dirname + '/../../lib/lmd_common.js'),\n    resolveName = common.getModuleFileByShortName,\n    assembleLmdConfig = common.assembleLmdConfig,\n    flagToOptionNameMap = common.LMD_PLUGINS;\n\nvar options = {\n    'sort': {\n        'describe': 'Sorts modules by that row',\n        'alias': 'order-by',\n        'default': 'undefined'\n    },\n    'deep': {\n        'describe': 'Prints deep module analytics',\n        'boolean': true,\n        'default': true\n    }\n};\n\nvar optimist = require('optimist');\n\nvar YES = ''.green,\n    NO = ''.yellow,\n    NO_YES = [NO, YES];\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd info ' + '<build_name>'.blue + '[' + '+<mixin>...+<mixin>'.cyan + ']' + ' [' + '<flags>'.green + ']' + ' [' + '<options>'.yellow + ']',\n        '',\n\n        'Example:'.bold.white.underline,\n        '',\n\n        '  lmd info ' + 'development'.blue,\n        '  lmd info ' + 'development'.blue + ' --sort=coverage'.yellow,\n        '  lmd info ' + 'development'.blue + '+corp'.cyan,\n        '  lmd info ' + 'development'.blue + '+en+corp'.cyan,\n        '  lmd info ' + 'development'.blue + '+sourcemap'.cyan,\n        '  lmd info ' + 'development'.blue + '+sourcemap'.cyan + ' --no-pack --async --js --css'.green,\n        '  lmd info ' + 'development'.blue + ' --modules.name=path.js'.green,\n        ''\n    ];\n\n    var options = optimist.help().split('\\n');\n    options.unshift(options[0].bold.white.underline);\n    options[1] = '';\n\n    help = help.concat(options);\n\n    cli.help(help, errorMessage);\n}\n\nfunction printValue(value) {\n    switch (typeof value) {\n        case \"boolean\":\n        case \"undefined\":\n            return NO_YES[+!!value];\n\n        case \"string\":\n            return value.green;\n\n        case \"object\":\n            return JSON.stringify(value, null, '    ').split('\\n')\n                .map(function (line, index) {\n                    return '\\n' + 'info'.green + ':    ' + line;\n                }).join('');\n\n        case \"function\":\n            return 'Function'.blue;\n    }\n\n    return value;\n}\n\nfunction printModules(cli, config, deepModulesInfo, conflicts, sortColumnName) {\n    var modulesCount = 0;\n    var bundles = common.groupModulesByBundles(config);\n    common.iterateModulesInfo(bundles, function () {\n        modulesCount++;\n    });\n\n    if (!modulesCount) {\n        return;\n    }\n\n    cli.ok(('Modules (' + modulesCount + ')').white.bold.underline);\n    cli.ok('');\n\n    var headers = ['name', 'depends', 'type', 'lazy', 'greedy', 'coverage', 'sandbox', 'bundle'];\n\n    var columnLengths = headers.map(function (item) {\n        return item.length;\n    });\n\n    var moduleRows = [];\n\n    common.iterateModulesInfo(bundles, function (module, moduleName, bundleName) {\n        var moduleExtra = deepModulesInfo[bundleName][moduleName];\n\n        if (moduleName.length > columnLengths[0]) {\n            columnLengths[0] = moduleName.length;\n        }\n\n        if (module.depends && module.depends.length > columnLengths[1]) {\n            columnLengths[1] = module.depends.length;\n        }\n\n        if (moduleExtra.type && moduleExtra.type.length > columnLengths[2]) {\n            columnLengths[2] = moduleExtra.type.length;\n        }\n\n        return moduleRows.push([\n            moduleName,\n            module.depends ? module.depends : false,\n            moduleExtra.type,\n            !!module.is_lazy,\n            !!module.is_greedy,\n            !!module.is_coverage,\n            !!module.is_sandbox,\n            bundleName === common.ROOT_BUNDLE_ID ? false : bundleName\n        ]);\n    });\n\n    var sortColumnIndex = headers.indexOf(sortColumnName);\n\n    if (sortColumnIndex != -1) {\n        moduleRows = moduleRows.sort(function (a, b) {\n            if (a[sortColumnIndex] > b[sortColumnIndex]) {\n                return 1;\n            }\n\n            if (a[sortColumnIndex] < b[sortColumnIndex]) {\n                return -1;\n            }\n\n            return 0;\n        });\n    }\n\n    moduleRows.unshift(headers);\n\n    moduleRows.forEach(function (row, rowIndex) {\n        var rowString = '',\n            isError = false;\n\n        row.forEach(function (item, index) {\n            var length = item.length || 1,\n                maxColumnLength = columnLengths[index] + 2;\n\n            //item = typeof item === \"boolean\" ? NO_YES[+item] : item;\n\n            if (!rowIndex) {\n                item = item.white.bold.underline;\n            }\n\n            if (!index && rowIndex) {\n                if (item in conflicts) {\n                    item = item.yellow;\n                } else {\n                    item = item.cyan;\n                }\n            }\n\n            // type=not-found\n            if (index === 2 && item === \"not-exists\") {\n                item = item.red;\n                isError = true;\n            } else if (index) {\n                item = printValue(item);\n            }\n\n            rowString += item + (maxColumnLength > length ? new Array(maxColumnLength - length).join(' ') : '  ');\n        });\n\n        if (isError) {\n            cli.error(rowString);\n        } else {\n            cli.ok(rowString);\n        }\n    });\n\n    cli.ok('');\n}\n\nfunction printStyles(cli, config) {\n    var styles = config.styles || [];\n    if (!styles.length) {\n        return;\n    }\n\n    cli.ok(('Styles (' + styles.length + ')').white.bold.underline);\n    cli.ok('');\n\n    styles.forEach(function (style) {\n        if (!style.is_exists) {\n            cli.error(style.path.red + ' (not exists)');\n        } else {\n            cli.ok(style.path.green);\n        }\n    });\n\n    cli.ok('');\n}\n\nfunction printFlags(cli, config, availableFlags) {\n    var longestName = availableFlags.reduce(function (max, current) {\n        if (typeof config[current] === \"undefined\") {\n            return max;\n        }\n        return current.length > max ? current.length : max;\n    }, 0);\n\n    if (!longestName) {\n        return;\n    }\n\n    longestName += 3;\n\n    cli.ok('Flags'.white.bold.underline);\n    cli.ok('');\n\n    availableFlags.forEach(function (flag) {\n        var value = config[flag];\n        if (typeof value === \"undefined\") {\n            return;\n        }\n\n        cli.ok(\n            flag.cyan +\n            (longestName > flag.length ? new Array(longestName - flag.length).join(' ') : '  ') +\n            printValue(value) +\n            (config.plugins_depends[flag] ? ' (depend of ' + config.plugins_depends[flag].join(', ').cyan + ')' : '')\n        );\n    });\n\n    cli.ok('');\n}\n\nfunction printModulePathsAndDepends(cli, config, deepModulesInfo, conflicts, isDeepAnalytics) {\n    var modulesCount = 0,\n        longestName = 0,\n        modulesNames = [];\n\n    var bundles = common.groupModulesByBundles(config);\n\n    common.iterateModulesInfo(bundles, function (module, name) {\n        modulesCount++;\n        if (longestName < name.length) {\n            longestName = name.length;\n        }\n        modulesNames.push(name);\n    });\n\n    var globalsNames = common.getGlobals(config);\n\n    if (!modulesCount) {\n        return;\n    }\n\n    cli.ok('Module Paths, Depends and Features'.white.bold.underline);\n    cli.ok('');\n\n    common.iterateModulesInfo(bundles, function (module, moduleName, bundleName) {\n        var moduleShortPadding = new Array(longestName - moduleName.length + 2).join(' '),\n            modulePath = [].concat(module.path);\n\n        var moduleLongPadding = new Array(moduleName.length + 5).join(' ') + moduleShortPadding;\n\n        if (module.is_exists) {\n            modulePath.forEach(function (modulePath, index) {\n                var moduleInfo;\n                if (moduleName in conflicts) {\n                    modulePath = modulePath.yellow;\n                } else {\n                    modulePath = modulePath.green;\n                }\n\n                if (!index) {\n                    moduleInfo = moduleName.cyan + moduleShortPadding + ' <- ' + modulePath;\n                } else {\n                    moduleInfo = moduleLongPadding + modulePath;\n                }\n\n                if (moduleName in conflicts) {\n                    cli.ok(moduleInfo + ' (name conflict)');\n                } else {\n                    cli.ok(moduleInfo);\n                }\n            });\n        } else {\n            modulePath.forEach(function (modulePath, index) {\n                var moduleInfo,\n                    // Module may consists of many parts, check each of them\n                    isModulePartExists = fs.existsSync(modulePath),\n                    color = isModulePartExists ? 'green' : 'red';\n\n                if (!index) {\n                    moduleInfo = moduleName.cyan + moduleShortPadding + ' <- ' + modulePath[color];\n                } else {\n                    moduleInfo = moduleLongPadding + modulePath[color];\n                }\n                cli.error(moduleInfo + (isModulePartExists ? '' : ' (not exists)'));\n            });\n        }\n        if (!isDeepAnalytics) {\n            return;\n        }\n        var depends = deepModulesInfo[bundleName][moduleName].depends;\n        if (depends.length) {\n            depends.forEach(function (name) {\n                var moduleType = common.discoverModuleType(name, modulesNames, globalsNames);\n                switch (moduleType) {\n                    case 'in-package':\n                        cli.ok(' +-' + name.toString().cyan);\n                        break;\n                    case 'global':\n                        cli.ok(' +-' + name.toString().cyan + ' (' + moduleType + ')');\n                        break;\n                    default:\n                        cli.ok(' +-' + name.toString().yellow + ' (' + moduleType + ')');\n                }\n            });\n        }\n        var features = Object.keys(deepModulesInfo[bundleName][moduleName].features);\n        if (features.length) {\n            cli.ok('  ' + 'Uses'.green + ': ' + features.join(', '));\n            cli.ok('');\n        }\n    });\n\n    cli.ok('');\n}\n\nfunction printUserPlugins(cli, config) {\n    var plugins = config.plugins || {},\n        pluginsNames = Object.keys(plugins);\n\n    if (!pluginsNames.length) {\n        return;\n    }\n\n    cli.ok('User plugins'.white.bold.underline);\n    cli.ok('');\n\n    var longestName = pluginsNames.reduce(function (max, name) {\n        return max < name.length ? name.length : max;\n    }, 0);\n\n    pluginsNames.forEach(function (name) {\n        var message = name.cyan + new Array(longestName - name.length + 2).join(' ') + ' <- ';\n\n        if (plugins[name].isOk) {\n            cli.ok(message + plugins[name].path.green);\n        } else {\n            cli.warn(message + plugins[name].path.red);\n        }\n    });\n\n    cli.ok('');\n}\n\nfunction getCompletionOptions(actionOptions) {\n    var plugins = Object.keys(common.LMD_PLUGINS),\n        flags = common.SOURCE_TWEAK_FLAGS,\n        fields = common.MASTER_FIELDS;\n\n    return  Object.keys(actionOptions)\n        // add options or flags\n        .reduce(function (all, current) {\n            all.push(current);\n\n            if (all.alias) {\n                all.push(all.alias);\n            }\n\n            return all;\n        }, [])\n        // +plugins\n        .concat(plugins)\n        // +no-plugins\n        .concat(plugins.map(function (name) {\n            return 'no-' + name;\n        }))\n        // +fields\n        .concat(fields)\n        // +no-flags (+flags are in master fields)\n        .concat(flags.map(function (flag) {\n            return 'no-' + flag;\n        }))\n        // add prefixes\n        .map(function (name) {\n            return '--' + name;\n        });\n}\n\nfunction getBuilds(cwd) {\n    return list.builds(cwd).map(function (file) {\n        return file.replace(common.RE_LMD_FILE, '');\n    });\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    for (var optionName in options) {\n        optimist.options(optionName, options[optionName]);\n    }\n\n    argv = optimist.parse(argv);\n\n    var buildName,\n        status,\n        mixinBuilds = argv._[1],\n        sortOrder = argv.sort,\n        isDeepAnalytics = argv.deep,\n        lmdDir = path.join(cwd, '.lmd');\n\n    if (mixinBuilds) {\n        mixinBuilds = mixinBuilds.split('+');\n\n        buildName = mixinBuilds.shift();\n    }\n\n    // Clear CLI options\n    delete argv.sort;\n    delete argv.deep;\n    delete argv['order-by'];\n    delete argv._;\n    delete argv.$0;\n\n    if (!init.check(cli, cwd)) {\n        return;\n    }\n\n    if (!buildName) {\n        printHelp(cli);\n        return;\n    }\n\n    status = create.checkFile(cwd, buildName);\n\n    if (status !== true) {\n        printHelp(cli, status === false ? 'build `' + buildName + '` is not exists' : status);\n        return;\n    }\n\n    // Check mixins\n    if (mixinBuilds.length) {\n        var isCanContinue = mixinBuilds.every(function (buildName) {\n            status = create.checkFile(cwd, buildName);\n\n            if (status !== true) {\n                printHelp(cli, status === false ? 'mixin build `' + buildName + '` is not exists' : status);\n                return false;\n            }\n            return true;\n        });\n\n        if (!isCanContinue) {\n            return;\n        }\n    }\n\n    mixinBuilds = mixinBuilds.map(function (mixinName) {\n        return resolveName(lmdDir, mixinName);\n    });\n\n    if (mixinBuilds.length) {\n        argv.mixins = mixinBuilds;\n    }\n\n    var buildFile = resolveName(lmdDir, buildName),\n        lmdFile = path.join(lmdDir, buildFile);\n\n    var rawConfig = common.readConfig(lmdFile),\n        flags = Object.keys(flagToOptionNameMap),\n        extraFlags = common.SOURCE_TWEAK_FLAGS,\n        config = assembleLmdConfig(lmdFile, flags, argv),\n        root = path.resolve(path.join(cwd, '.lmd'), config.root),\n        output = config.output ? path.resolve(root, config.output) : 'STDOUT'.yellow,\n        styles_output = config.styles_output ? path.resolve(root, config.styles_output) : '/dev/null'.yellow,\n        sourcemap = config.sourcemap ? path.resolve(root, config.sourcemap) : false,\n        www = config.www_root ? path.resolve(path.join(cwd, '.lmd'), config.www_root) : false,\n        versionString = config.version ? ' - version ' + config.version.toString().cyan : '';\n\n    cli.ok('');\n    cli.ok('LMD Package `' + buildName.green + '` (' + path.join('.lmd', buildFile).green + ')' + versionString);\n    cli.ok('');\n\n    if (rawConfig.extends) {\n        cli.ok('Extends LMD Package `' + (rawConfig.extends + '').green + '`');\n        cli.ok('');\n    }\n\n    if (config.mixins) {\n        cli.ok('Mixins LMD Package ' + config.mixins.map(function (mixin) {\n            return mixin.green;\n        }).join(', '));\n        cli.ok('');\n    }\n\n    if (config.name || config.description) {\n        config.name && cli.ok(config.name.toString().white.bold);\n        if (config.description) {\n            // Multiline description\n            var descriptionLines = config.description.toString().split('\\n');\n            descriptionLines.forEach(function (line) {\n                cli.ok(line);\n            });\n        }\n        cli.ok('');\n    }\n\n    var deepModulesInfo = common.collectModulesInfo(config),\n        conflicts = common.getSuspiciousNames(config, deepModulesInfo).conflicts;\n\n    printModules(cli, config, deepModulesInfo, conflicts, sortOrder);\n    printModulePathsAndDepends(cli, config, deepModulesInfo, conflicts, isDeepAnalytics);\n    printStyles(cli, config);\n    printUserPlugins(cli, config);\n    printFlags(cli, config, flags.concat(extraFlags));\n\n    cli.ok('Paths'.white.bold.underline);\n    cli.ok('');\n    cli.ok('root'.cyan + '           ' + printValue(root));\n    cli.ok('output'.cyan + '         ' + printValue(output));\n    cli.ok('styles_output'.cyan + '  ' + printValue(styles_output));\n    cli.ok('www_root'.cyan + '       ' + printValue(www));\n\n    if (sourcemap) {\n        cli.ok('');\n        cli.ok('Source Map'.white.bold.underline);\n        cli.ok('');\n\n        cli.ok('sourcemap'.cyan + '         ' + printValue(sourcemap));\n        cli.ok('sourcemap_www'.cyan + '     ' + printValue(config.sourcemap_www || '/'));\n        cli.ok('sourcemap_inline'.cyan + '  ' + printValue(config.sourcemap_inline));\n        cli.ok('sourcemap_url'.cyan + '     ' + printValue(config.sourcemap_url || '/' + sourcemap.replace(www, '')));\n    }\n\n    var errors = config.errors;\n\n    // pipe warnings\n    common.iterateModulesInfo(deepModulesInfo, function (info) {\n        errors.push.apply(errors, info.warns)\n    });\n\n    errors = errors.concat(common.collectFlagsWarnings(config, deepModulesInfo));\n\n    if (errors && errors.length) {\n        cli.warn('');\n        cli.warn('Warnings'.red.bold.underline);\n        cli.warn('');\n        errors.forEach(function (error) {\n            cli.warn(error);\n        });\n    }\n\n    common.collectFlagsNotifications(config).forEach(function (notification) {\n        cli.ok(notification);\n    });\n\n    cli.ok('');\n};\n\nmodule.exports.getCompletionOptions = getCompletionOptions;\nmodule.exports.getBuilds = getBuilds;\n\nmodule.exports.completion = function (cli, argv, cwd, completionOptions) {\n    // module name completion\n    if (completionOptions.index === 1) {\n        var builds = getBuilds(cwd);\n\n        return cli.log(builds.join('\\n'));\n    }\n\n    // <flags> & <options>\n    if (completionOptions.index > 1) {\n        var flagsOptions = getCompletionOptions(options);\n\n        return cli.log(flagsOptions.join('\\n'));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/init.js":"var fs = require('fs'),\n    path = require('path');\n\nfunction checkLmdDir(cwd) {\n    var lmdDir = cwd + '/.lmd';\n    if (fs.existsSync(lmdDir)) {\n        if (fs.statSync(lmdDir).isDirectory()) {\n            return true;\n        }\n        return '.lmd is not a dir';\n    }\n\n    return false;\n}\n\nfunction createLmdStructure(cwd) {\n    var lmdDir = path.join(cwd, '.lmd');\n    fs.mkdirSync(lmdDir);\n}\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd init',\n        ''\n    ];\n\n    cli.help(help, errorMessage);\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    var status = checkLmdDir(cwd);\n    if (status) {\n        printHelp(cli, status === true ? '.lmd is already initialised' : status);\n        return;\n    }\n\n    createLmdStructure(cwd);\n    cli.ok('');\n    cli.ok('.lmd initialised');\n    cli.ok('');\n};\n\nmodule.exports.check = function (cli, cwd) {\n    var status = checkLmdDir(cwd);\n    if (status !== true) {\n        printHelp(cli, status ? status : 'run `lmd init` to initialise LMD in ' + cwd);\n        return false;\n    }\n\n    return true;\n};","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/list.js":"require('colors');\n\nvar fs = require('fs'),\n    path = require('path'),\n    init = require(__dirname + '/init.js'),\n    create = require(__dirname + '/create.js'),\n    common = require(__dirname + '/../../lib/lmd_common.js');\n\nvar reLmdFile = common.RE_LMD_FILE;\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd list',\n        ''\n    ];\n\n    cli.help(help, errorMessage);\n}\n\nfunction builds(cwd) {\n    var lmdDir = path.join(cwd, '.lmd');\n\n    return fs.readdirSync(lmdDir)\n        .filter(function (name) {\n            return fs.statSync(path.join(lmdDir, name)).isFile() && reLmdFile.test(name);\n        });\n}\n\nfunction listOfFiles(cli, cwd) {\n    var lmdDir = path.join(cwd, '.lmd');\n\n    var files = builds(cwd);\n\n    if (!files.length) {\n        cli.ok('');\n        cli.ok('No LMD builds. Type lmd create for more info');\n        cli.ok('');\n        return;\n    }\n\n    cli.ok('');\n    cli.ok('Available builds'.white.bold.underline);\n    cli.ok('');\n\n    var longestName = files.reduce(function (max, current) {\n        return current.length > max ? current.length : max;\n    }, 0);\n\n    files.forEach(function (name) {\n        var extraSpaces = new Array(longestName - name.length + 3).join(' '),\n            buildName = common.readConfig(lmdDir, name).name || '';\n\n        name = name.replace(reLmdFile, '');\n        cli.ok(name.cyan + extraSpaces + buildName);\n    });\n    cli.ok('');\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    if (!init.check(cli, cwd)) {\n        return;\n    }\n\n    listOfFiles(cli, cwd);\n};\n\nmodule.exports.builds = builds;\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/old.js":"/**\n * LMD\n *\n * @author  Mikhail Davydov\n * @licence MIT\n */\n\nvar lmdPackage = require(__dirname + '/../lmd_builder.js'),\n    fs = require('fs');\n\n/**\n *\n *\n * @type {String[]}\n */\nvar availableModes = ['main', 'watch'];\n\n/**\n * Simple argv parser\n *\n * @see https://gist.github.com/1497865\n *\n * @param {String} a an argv string\n *\n * @returns {Object}\n */\nvar parseArgv = function (a,b,c,d) {\n    c={};for(a=a.split(/\\s*\\B[-]+([\\w-]+)[\\s=]*/),d=1;b=a[d++];c[b]=a[d++]||!0);return c\n};\n\nvar createWritableFile = function (fileName) {\n    return fs.createWriteStream(fileName, {\n        flags: \"w\",\n        encoding: \"utf8\",\n        mode: 0666\n    });\n};\n\n/**\n * Formats lmd config\n *\n * @param  {String|Object} data\n *\n * @return {Object}\n */\nvar parseData = function (data) {\n    var config;\n\n    // case data is argv string\n    if (typeof data === \"string\") {\n        // try to parse new version\n        config = parseArgv(data);\n\n        // its new config argv string\n        if (Object.keys(config).length) {\n            // translate short params to long one\n            config.mode = config.mode || config.m;\n            config.output = config.output || config.o;\n            config.log = config.log || config.l;\n            config.config = config.config || config.c;\n            config['no-warn'] = config['no-warn'] || config['no-w'];\n            config['source-map'] = config['source-map'] || config['sm'];\n            config['source-map-root'] = config['source-map-root'] || config['sm-root'];\n            config['source-map-www'] = config['source-map-www'] || config['sm-www'];\n            config['source-map-inline'] = config['source-map-inline'] || config['sm-inline'];\n        } else {\n            // an old argv format, split argv and parse manually\n            data = data.split(' ');\n\n            // without mode\n            if (availableModes.indexOf(data[2]) === -1) {\n                config = {\n                    mode: 'main',\n                    config: data[2],\n                    output: data[3]\n                };\n            } else { // with mode\n                config = {\n                    mode: data[2],\n                    config: data[3],\n                    output: data[4]\n                };\n            }\n        }\n\n    // case data is config object\n    } else if (typeof config === \"object\") {\n        // use as is\n        config = data;\n\n    // case else\n    } else {\n        // wut?\n        throw new Error('Bad config data');\n    }\n\n    config.mode = config.mode || 'main';\n    config.warn = !config['no-warn'];\n    config.sourcemap = config['source-map'] || false;\n    config.www_root = config['source-map-root'] || \"\";\n    config.sourcemap_www = config['source-map-www'] || \"\";\n    config.sourcemap_inline = config['source-map-inline'] || false;\n    config.log = config.log || false;\n\n    return config;\n};\n\nmodule.exports = function (argv) {\n\n    var config = parseData(argv.join(' ')),\n        builderOptions = {\n            warn: config.warn,\n            sourcemap: config.sourcemap,\n            www_root: config.www_root,\n            sourcemap_www: config.sourcemap_www,\n            sourcemap_inline: config.sourcemap_inline,\n            output: config.output\n        };\n\n    switch (config.mode) {\n        case 'main':\n            var buildResult = new lmdPackage(config.config, builderOptions);\n            // usage log\n            if (!config.config) {\n                buildResult.log.pipe(process.stdout);\n                break;\n            }\n\n            if (builderOptions.sourcemap) {\n                buildResult.sourceMap.pipe(createWritableFile(builderOptions.sourcemap));\n            }\n\n            if (builderOptions.output) {\n                buildResult.pipe(createWritableFile(builderOptions.output));\n                if (config.log) {\n                    buildResult.log.pipe(process.stdout);\n                }\n            } else {\n                buildResult.pipe(process.stdout);\n            }\n            break;\n        case 'watch':\n            var watcher = new lmdPackage.watch(config.config, builderOptions);\n            // usage log\n            if (!config.config || !builderOptions.output) {\n                watcher.log.pipe(process.stdout);\n                break;\n            }\n\n            if (config.log) {\n                watcher.log.pipe(process.stdout);\n            }\n            break;\n    }\n\n};","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/server.js":"require('colors');\n\nvar fs = require('fs'),\n    path = require('path'),\n    cli = require(__dirname + '/../cli_messages.js'),\n    init = require(__dirname + '/init.js'),\n    create = require(__dirname + '/create.js'),\n    info = require(__dirname + '/info.js'),\n    common = require(__dirname + '/../../lib/lmd_common.js'),\n    resolveName = common.getModuleFileByShortName,\n    LmdStatsServer = require(__dirname + '/../../stats_server/index.js'),\n    assembleLmdConfig = common.assembleLmdConfig,\n    flagToOptionNameMap = common.LMD_PLUGINS;\n\nvar options = {\n    'address': {\n        'describe': 'Client stats server address. Log receiver',\n        'alias': 'a',\n        'default': '0.0.0.0'\n    },\n    'port': {\n        'describe': 'Client stats server port',\n        'alias': 'p',\n        'default': '8081'\n    },\n    'admin-address': {\n        'describe': 'Admin interface server address. Default same as `address`',\n        'alias': 'aa'\n    },\n    'admin-port': {\n        'describe': 'Admin interface server port. Default same as `port`',\n        'alias': 'ap'\n    }\n};\n\nvar optimist = require('optimist');\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd server ' + '<build_name>'.blue + ' [' + '<options>'.yellow + ']',\n        '',\n\n        'Example:'.bold.white.underline,\n        '',\n\n        '  lmd server ' + 'development'.blue,\n        '  lmd server ' + 'development'.blue + ' --a localhost --p 8080'.yellow,\n        ''\n    ];\n\n    var options = optimist.help().split('\\n');\n    options.unshift(options[0].bold.white.underline);\n    options[1] = '';\n\n    help = help.concat(options);\n\n    cli.help(help, errorMessage);\n}\n\nfunction ensureDirExists(path) {\n    if (fs.existsSync(path)) {\n        if (!fs.statSync(path).isDirectory()) {\n            printHelp('Required directory is file ' + path);\n            return false;\n        }\n    } else {\n        fs.mkdirSync(path);\n    }\n\n    return true;\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    for (var optionName in options) {\n        optimist.options(optionName, options[optionName]);\n    }\n    argv = optimist.parse(argv);\n\n    var status,\n        buildName = argv._[1];\n\n    if (!init.check(cli, cwd)) {\n        return;\n    }\n\n    if (!buildName) {\n        printHelp(cli);\n        return;\n    }\n\n    status = create.checkFile(cwd, buildName);\n\n    if (status !== true) {\n        if (status !== false) {\n            printHelp(cli, status);\n        } else if (buildName.indexOf('+') !== -1) {\n            // Warn if mixins\n            printHelp(cli, 'mixins `' + buildName + '` are not allowed with server action');\n        } else {\n            printHelp(cli, 'build `' + buildName + '` is not exists');\n        }\n        return;\n    }\n    var lmdDir = path.join(cwd, '.lmd'),\n        buildFile = resolveName(lmdDir, buildName),\n        lmdFile = path.join(lmdDir, buildFile);\n\n    var config = assembleLmdConfig(lmdFile, Object.keys(flagToOptionNameMap)),\n        logsDir = path.join(cwd, '.lmd', 'logs'),\n        currentLogDir = path.join(logsDir, buildName);\n\n    if (!config.www_root) {\n        printHelp(cli, \"Build configured without required parameter `www_root`\");\n        return;\n    }\n\n    var wwwDir = path.resolve(path.join(cwd, '.lmd'), String(config.www_root));\n\n    if (!config.stats) {\n        printHelp(cli, \"Build configured without `stats` flag\");\n        return;\n    }\n\n    if (!ensureDirExists(logsDir)) {\n        return;\n    }\n\n    if (!ensureDirExists(currentLogDir)) {\n        return;\n    }\n\n    new LmdStatsServer({\n        address: argv.address,\n        port: +argv.port,\n        'admin-address': argv['admin-address'] || argv.address,\n        'admin-port': +(argv['admin-address'] || argv.port),\n        config: lmdFile,\n        log: currentLogDir,\n        www: wwwDir\n    });\n\n};\n\nmodule.exports.completion = function (cli, argv, cwd, completionOptions) {\n    // module name completion\n    if (completionOptions.index === 1) {\n        var builds = info.getBuilds(cwd);\n\n        return cli.log(builds.join('\\n'));\n    }\n\n    // <flags> & <options>\n    if (completionOptions.index > 1) {\n        var flagsOptions = info.getCompletionOptions(options);\n\n        return cli.log(flagsOptions.join('\\n'));\n    }\n};","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/update.js":"require('colors');\n\nvar fs = require('fs'),\n    path = require('path'),\n    init = require(__dirname + '/init.js'),\n    create = require(__dirname + '/create.js'),\n    info = require(__dirname + '/info.js'),\n    common = require(__dirname + '/../../lib/lmd_common.js'),\n    resolveName = common.getModuleFileByShortName;\n\nvar optimist = require('optimist');\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd update ' + '<build_name>'.blue + ' ' + '<flags>'.green,\n        '',\n\n        'Example:'.bold.white.underline,\n        '',\n\n        '  lmd update ' + 'development'.blue + ' --no-pack --async --js --css'.green,\n        '  lmd update ' + 'development'.blue + ' --modules.name=path.js'.green,\n        ''\n    ];\n\n    cli.help(help, errorMessage);\n}\n\nfunction template(json, options) {\n    if (options) {\n        json = common.deepDestructableMerge(json, options);\n    }\n\n    return JSON.stringify(json, null, '    ');\n}\n\nfunction updateBuild(cwd, buildFile, options) {\n    var lmdConfig = path.join(cwd, '.lmd', buildFile),\n        json = common.readConfig(lmdConfig);\n\n    fs.writeFileSync(lmdConfig, template(json, options), 'utf8');\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    argv = optimist.parse(argv);\n\n    var status,\n        buildName = argv._[1];\n\n    delete argv._;\n    delete argv.$0;\n\n    if (!init.check(cli, cwd)) {\n        return;\n    }\n\n    if (!buildName) {\n        printHelp(cli);\n        return;\n    }\n\n    status = create.checkFile(cwd, buildName);\n\n    if (status !== true) {\n        printHelp(cli, status === false ? 'build `' + buildName + '` is not exists' : status);\n        return;\n    }\n\n    var extraFlags = Object.keys(argv),\n        lmdDir = path.join(cwd, '.lmd'),\n        buildFile = resolveName(lmdDir, buildName);\n\n    if (extraFlags.length) {\n        updateBuild(cwd, buildFile, argv);\n\n        cli.ok('');\n        cli.ok('Build `' + buildName.green + '` (' + path.join('.lmd', buildFile).green + ') updated');\n        cli.ok('');\n\n        cli.ok('These options are changed'.cyan.bold + ':');\n        cli.ok('');\n\n        var offset = extraFlags.reduce(function (longest, current) {\n            return current.length > longest ? current.length : longest;\n        }, 0);\n\n        offset += 3;\n\n        extraFlags.forEach(function (flagName) {\n            var spaces = new Array(offset - flagName.length).join(' ');\n\n            cli.ok('  ' + flagName.green + spaces + JSON.stringify(argv[flagName]));\n        });\n        cli.ok('');\n    } else {\n        printHelp(cli);\n    }\n};\n\nmodule.exports.completion = function (cli, argv, cwd, completionOptions) {\n    // module name completion\n    if (completionOptions.index === 1) {\n        var builds = info.getBuilds(cwd);\n\n        return cli.log(builds.join('\\n'));\n    }\n\n    // <flags> & <options>\n    if (completionOptions.index > 1) {\n        var flagsOptions = info.getCompletionOptions({});\n\n        return cli.log(flagsOptions.join('\\n'));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/bin/lmd_actions/watch.js":"require('colors');\n\nvar fs = require('fs'),\n    path = require('path'),\n    cli = require(__dirname + '/../cli_messages.js'),\n    init = require(__dirname + '/init.js'),\n    create = require(__dirname + '/create.js'),\n    info = require(__dirname + '/info.js'),\n    common = require(__dirname + '/../../lib/lmd_common.js'),\n    resolveName = common.getModuleFileByShortName,\n    lmdPackage = require(__dirname + '/../lmd_builder.js');\n\nvar optimist = require('optimist');\n\nfunction printHelp(cli, errorMessage) {\n    var help = [\n        'Usage:'.bold.white.underline,\n        '',\n\n        '  lmd watch ' + '<build_name>'.blue + '[' + '+<mixin>...+<mixin>'.cyan + ']' + ' [' + '<flags>'.green + ']',\n        '',\n\n        'Example:'.bold.white.underline,\n        '',\n\n        '  lmd watch ' + 'development'.blue,\n        '  lmd watch ' + 'development'.blue + '+corp'.cyan,\n        '  lmd watch ' + 'development'.blue + '+en+corp'.cyan,\n        '  lmd watch ' + 'development'.blue + '+sourcemap'.cyan,\n        '  lmd watch ' + 'development'.blue + '+sourcemap'.cyan + ' --no-pack --async --js --css'.green,\n        '  lmd watch ' + 'development'.blue + ' --modules.name=path.js'.green,\n        ''\n    ];\n\n    cli.help(help, errorMessage);\n}\n\nmodule.exports = function (cli, argv, cwd) {\n    argv = optimist.parse(argv);\n\n    var status,\n        buildName,\n        mixinBuilds = argv._[1],\n        lmdDir = path.join(cwd, '.lmd');\n\n    if (mixinBuilds) {\n        mixinBuilds = mixinBuilds.split('+');\n\n        buildName = mixinBuilds.shift();\n    }\n\n    delete argv._;\n    delete argv.$0;\n\n    if (!init.check(cli, cwd)) {\n        return;\n    }\n\n    if (!buildName) {\n        printHelp(cli);\n        return;\n    }\n\n    status = create.checkFile(cwd, buildName);\n\n    if (status !== true) {\n        printHelp(cli, status === false ? 'build `' + buildName + '` is not exists' : status);\n        return;\n    }\n\n    // Check mixins\n    if (mixinBuilds.length) {\n        var isCanContinue = mixinBuilds.every(function (buildName) {\n            status = create.checkFile(cwd, buildName);\n\n            if (status !== true) {\n                printHelp(cli, status === false ? 'mixin build `' + buildName + '` is not exists' : status);\n                return false;\n            }\n            return true;\n        });\n\n        if (!isCanContinue) {\n            return;\n        }\n    }\n\n    mixinBuilds = mixinBuilds.map(function (mixinName) {\n        return resolveName(lmdDir, mixinName);\n    });\n\n    if (mixinBuilds.length) {\n        argv.mixins = mixinBuilds;\n    }\n\n    var lmdFile = path.join(lmdDir, resolveName(lmdDir, buildName));\n\n    var watchResult = new lmdPackage.watch(lmdFile, argv),\n        watchConfig = watchResult.watchConfig;\n\n    if (watchConfig.log) {\n        watchResult.log.pipe(cli.stream);\n    }\n\n};\n\nmodule.exports.completion = function (cli, argv, cwd, completionOptions) {\n    // module name completion\n    if (completionOptions.index === 1) {\n        var builds = info.getBuilds(cwd);\n\n        return cli.log(builds.join('\\n'));\n    }\n\n    // <flags> & <options>\n    if (completionOptions.index > 1) {\n        var flagsOptions = info.getCompletionOptions({});\n\n        return cli.log(flagsOptions.join('\\n'));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/amd.js":"/**\n * @name sandbox\n */\n(function (sb) {\n\nvar amdModules = {},\n    currentModule,\n    currentRequire;\n\n/**\n * RequireJS & AMD-style define\n *\n * (function (require) {\n *     var define = require.define;\n *\n *     define([\"a\"], function (a) {\n *          return a + 2;\n *     });\n * })\n *\n * @param name\n * @param deps\n * @param module\n */\nvar define = function (name, deps, module) {\n    switch (arguments.length) {\n        case 1: // define(function () {})\n            module = name;\n            deps = name = sb.undefined;\n            break;\n\n        case 2: // define(['a', 'b'], function () {})\n            module = deps;\n            deps = name;\n            name = sb.undefined;\n            break;\n\n        case 3: // define('name', ['a', 'b'], function () {})\n    }\n\n    if (typeof module !== \"function\") {\n        amdModules[currentModule] = module;\n        return;\n    }\n\n    var output = {'exports': {}};\n    if (!deps) {\n        deps = [\"require\", \"exports\", \"module\"];\n    }\n    for (var i = 0, c = deps.length; i < c; i++) {\n        switch (deps[i]) {\n            case \"require\":\n                deps[i] = currentRequire;\n                break;\n            case \"module\":\n                deps[i] = output;\n                break;\n            case \"exports\":\n                deps[i] = output.exports;\n                break;\n            default:\n                deps[i] = currentRequire && currentRequire(deps[i]);\n        }\n    }\n    module = module.apply(this, deps) || output.exports;\n    amdModules[currentModule] = module;\n};\n\n// #183 define.amd should be defined\ndefine.amd = {\n    jQuery: true\n};\n\nsb.require.define = define;\n\n// First called this than called few of define\nsb.on('lmd-register:decorate-require', function (moduleName, require) {\n    var options = sb.modules_options[moduleName] || {};\n    // grab current require and module name\n    currentModule = moduleName;\n\n    if (options.sandbox) {\n        currentRequire = sb.undefined;\n        if (typeof require === \"function\") {\n            require = {};\n        }\n        require.define = define;\n    } else {\n        currentRequire = require;\n    }\n\n    return [moduleName, require];\n});\n\n// Than called this\nsb.on('lmd-register:after-register', function (moduleName, module) {\n    if (amdModules.hasOwnProperty(currentModule)) {\n        module = amdModules[currentModule];\n        delete amdModules[currentModule];\n\n        return [moduleName, module];\n    }\n});\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/async.js":"/**\n * Async loader of off-package LMD modules (special LMD format file)\n *\n * @see /README.md near \"LMD Modules types\" for details\n *\n * Flag \"async\"\n *\n * This plugin provides require.async() function\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * Load off-package LMD module\n     *\n     * @param {String|Array} moduleName same origin path to LMD module\n     * @param {Function}     [callback]   callback(result) undefined on error others on success\n     */\n    sb.require.async = function (moduleName, callback) {\n        return sb.trigger('*:preload', moduleName, callback, 'async')[0];\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/bundle.js":"/**\n * Bundle loader\n *\n * Flag \"bundle\"\n *\n * This plugin provides require.bundle() function\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n    var callbackName = sb.options.bundle,\n        pendingBundlesLength = 0;\n\n    /**\n     * Cases:\n     *     ({main}, {modules}, {options})\n     *     ({modules}, {options})\n     *     ({modules})\n     *\n     * @param {Function} _main\n     * @param {Object}   _modules\n     * @param {Object}   _modules_options\n     */\n    var processBundleJSONP = function (_main, _modules, _modules_options) {\n        if (typeof _main === \"object\") {\n            _modules_options = _modules;\n            _modules = _main;\n        }\n\n        for (var moduleName in _modules) {\n            // if already initialized - skip\n            if (moduleName in sb.modules) {\n                continue;\n            }\n\n            // declare new modules\n            sb.modules[moduleName] = _modules[moduleName];\n            sb.initialized[moduleName] = 0;\n\n            // declare module options\n            if (_modules_options && moduleName in _modules_options) {\n                sb.modules_options[moduleName] = _modules_options[moduleName];\n            }\n        }\n\n        if (typeof _main === \"function\") {\n            var output = {'exports': {}};\n            _main(sb.trigger('lmd-register:decorate-require', \"<bundle:main>\", sb.require)[1], output.exports, output);\n        }\n    };\n\n    var trap = function () {\n        pendingBundlesLength++;\n        // make trap\n        sb.global[callbackName] = processBundleJSONP;\n    };\n\n    var cleanup = function (callback, scriptTag) {\n        // Be sure that callback will be called after script eval\n        setTimeout(function () {\n            pendingBundlesLength--;\n            // cleanup if no pending bundles\n            if (!pendingBundlesLength) {\n                sb.global[callbackName] = sb.undefined;\n            }\n            callback(scriptTag);\n        }, 10);\n    };\n\n    /**\n     * Loads LMD bundle\n     *\n     * @param {String|Array} bundleSrc path to file\n     * @param {Function}     [callback]   callback(result) undefined on error HTMLScriptElement on success\n     */\n    sb.require.bundle = function (bundleSrc, callback) {\n        var replacement = sb.trigger('*:request-off-package', bundleSrc, callback, 'image'), // [[returnResult, bundleSrc, bundle, true], callback, type]\n            returnResult = replacement[0][0];\n\n        if (replacement[0][3]) { // isReturnASAP\n            return returnResult;\n        }\n\n        callback = replacement[1];\n        bundleSrc = replacement[0][1];\n\n        trap();\n\n        sb.trigger('*:load-script', bundleSrc, function (scriptTag) {\n            cleanup(callback, scriptTag);\n        });\n\n        return returnResult;\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/cache_async.js":"/**\n * This plugin dumps off-package modules content to localStorage\n *\n * Flag \"cache_async\"\n *\n * Provides cache_async function\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n\nfunction cache_async(moduleName, module) {\n    if (sb.global.localStorage && sb.options.version) {\n        var scriptElement = sb.document.getElementById('lmd-initializer'),\n            storageKey = scriptElement ? scriptElement.getAttribute('data-key') : 'lmd';\n\n        try {\n            sb.global.localStorage[storageKey + ':' + sb.options.version + ':' + moduleName] = sb.global.JSON.stringify(module);\n        } catch(e) {}\n    }\n}\n    /**\n     * @event async:before-callback when async.js require is going to return module, uses for cache async module\n     *\n     * @param {String} moduleName\n     * @param {String} module     module content\n     *\n     * @retuns no\n     */\nsb.on('preload:before-callback', function (moduleName, module) {\n    cache_async(moduleName, module);\n});\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/cache.js":"/**\n * This plugin dumps modules content to localStorage\n *\n * Flag \"cache\"\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n\n    // If possible to dump and version passed (fallback mode)\n    // then dump application source\n    if (sb.global.localStorage && sb.options.version/*if ($P.OPERA_MOBILE) {*/ && /_/.test(function(){_()}) /*}*/) {\n        (function () {\n            var scriptElement = sb.document.getElementById('lmd-initializer'),\n                storageKey = scriptElement ? scriptElement.getAttribute('data-key') : 'lmd';\n\n            try {\n                sb.global.localStorage[storageKey] = sb.global.JSON.stringify({\n                    modules: sb.modules,\n                    // main module function\n                    main: '(' + sb.main + ')',\n                    // lmd function === arguments.callee\n                    lmd: '(' + sb.lmd + ')',\n                    modules_options: sb.modules_options,\n                    options: sb.options\n                });\n            } catch(e) {}\n        }());\n    }\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/css.js":"/**\n * Async loader of css files\n *\n * Flag \"css\"\n *\n * This plugin provides require.css() function\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n\n    /**\n     * Loads any CSS file\n     *\n     * Inspired by yepnope.css.js\n     *\n     * @see https://github.com/SlexAxton/yepnope.js/blob/master/plugins/yepnope.css.js\n     *\n     * @param {String|Array} moduleName path to css file\n     * @param {Function}     [callback]   callback(result) undefined on error HTMLLinkElement on success\n     */\n    sb.require.css = function (moduleName, callback) {\n        var replacement = sb.trigger('*:request-off-package', moduleName, callback, 'css'), // [[returnResult, moduleName, module, true], callback, type]\n            returnResult = replacement[0][0];\n\n        if (replacement[0][3]) { // isReturnASAP\n            return returnResult;\n        }\n\n        var module = replacement[0][2],\n            isNotLoaded = 1,\n            head;\n\n        callback = replacement[1];\n        moduleName = replacement[0][1];\n\n/*if ($P.WORKER || $P.NODE) {*///#JSCOVERAGE_IF 0/*}*/\n        // Create stylesheet link\n        var link = sb.document.createElement(\"link\"),\n            id = Math.random() + '',\n            onload = function () {\n                if (isNotLoaded) {\n                    isNotLoaded = 0;\n                    // register or cleanup\n                    link.removeAttribute('id');\n\n                    callback(sb.register(moduleName, link)); // e === undefined if error\n                }\n            };\n\n        // Add attributes\n        link.href = moduleName;\n        link.rel = \"stylesheet\";\n        link.id = id;\n\n        head = sb.document.getElementsByTagName(\"head\")[0];\n        head.insertBefore(link, head.firstChild);\n\n        function isRules(sheet) {\n            if ((sheet.ownerNode || sheet.owningElement).id != id) {\n                return false;\n            }\n            try {\n                // It can be null or throw an Security error in case of cross origin stylesheets\n                return !!(sheet.cssRules || sheet.rules).length;\n            } catch (e) {\n                // In case of access error assume that css is loaded\n                return true;\n            }\n        }\n\n        (function poll() {\n            if (isNotLoaded) {\n                var sheets = sb.document.styleSheets,\n                    j = 0,\n                    k = sheets.length;\n\n                try {\n                    for (; j < k; j++) {\n                        if (isRules(sheets[j])) {\n//#JSCOVERAGE_IF 0\n                            return onload();\n//#JSCOVERAGE_ENDIF\n                        }\n                    }\n                    // if we get here, its not in document.styleSheets (we never saw the ID)\n                    throw 1;\n                } catch(e) {\n                    // Keep polling\n                    sb.global.setTimeout(poll, 90);\n                }\n            }\n        }());\n\n        return returnResult;\n/*if ($P.WORKER || $P.NODE) {*///#JSCOVERAGE_ENDIF/*}*/\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/ie.js":"/**\n * @name sandbox\n */\n(function (sb) {\n\n// Simple JSON stringify\nfunction stringify(object) {\n    var properties = [];\n    for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n            properties.push(quote(key) + ':' + getValue(object[key]));\n        }\n    }\n    return \"{\" + properties.join(\",\") + \"}\";\n}\n\nfunction getValue(value) {\n    if (typeof value === \"string\") {\n        return quote(value);\n    } else if (typeof value === \"boolean\") {\n        return \"\" + value;\n    } else if (value.join) {\n        if (value.length == 0) {\n            return \"[]\";\n        } else {\n            var flat = [];\n            for (var i = 0, len = value.length; i < len; i += 1) {\n                flat.push(getValue(value[i]));\n            }\n            return '[' + flat.join(\",\") + ']';\n        }\n    } else if (typeof value === \"number\") {\n        return value;\n    } else {\n        return stringify(value);\n    }\n}\n\nfunction pad(s) {\n    return '0000'.substr(s.length) + s;\n}\n\nfunction replacer(c) {\n    switch (c) {\n        case '\\b': return '\\\\b';\n        case '\\f': return '\\\\f';\n        case '\\n': return '\\\\n';\n        case '\\r': return '\\\\r';\n        case '\\t': return '\\\\t';\n        case '\"': return '\\\\\"';\n        case '\\\\': return '\\\\\\\\';\n        default: return '\\\\u' + pad(c.charCodeAt(0).toString(16));\n    }\n}\n\nfunction quote(s) {\n    return '\"' + s.replace(/[\\u0000-\\u001f\"\\\\\\u007f-\\uffff]/g, replacer) + '\"';\n}\n\nfunction indexOf(item) {\n    for (var i = this.length; i --> 0;) {\n        if (this[i] === item) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n    /**\n     * @event *:request-json requests JSON polifill with only stringify function!\n     *\n     * @param {Object|undefined} JSON default JSON value\n     *\n     * @retuns yes\n     */\nsb.on('*:request-json', function (JSON) {\n    if (typeof JSON === \"object\") {\n        return [JSON];\n    }\n\n    return [{stringify: stringify}];\n});\n\n    /**\n     * @event *:request-indexof requests indexOf polifill\n     *\n     * @param {Function|undefined} arrayIndexOf default indexOf value\n     *\n     * @retuns yes\n     */\nsb.on('*:request-indexof', function (arrayIndexOf) {\n    if (typeof arrayIndexOf === \"function\") {\n        return [arrayIndexOf];\n    }\n\n    return [indexOf];\n});\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/image.js":"/**\n * Image loader plugin\n *\n * Flag \"image\"\n *\n * This plugin provides require.image() function\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * Loads any image\n     *\n     * @param {String|Array} moduleName path to file\n     * @param {Function}     [callback]   callback(result) undefined on error HTMLImageElement on success\n     */\n    sb.require.image = function (moduleName, callback) {\n        var replacement = sb.trigger('*:request-off-package', moduleName, callback, 'image'), // [[returnResult, moduleName, module, true], callback, type]\n            returnResult = replacement[0][0];\n\n        if (replacement[0][3]) { // isReturnASAP\n            return returnResult;\n        }\n\n        var module = replacement[0][2];\n\n        callback = replacement[1];\n        moduleName = replacement[0][1];\n\n/*if ($P.WORKER || $P.NODE) {*///#JSCOVERAGE_IF 0/*}*/\n        var img = new Image();\n        /*if ($P.IE) {*/var cleanup = function () {try {delete img.onload; delete img.onerror;} catch (err) {img.onload = img.onerror = sb.noop;}};/*}*/\n        img.onload = function () {\n            callback(sb.register(moduleName, img));\n            /*if ($P.IE) {*/cleanup();/*}*/\n        };\n        img.onerror = function () {\n            sb.trigger('*:request-error', moduleName, module);\n            callback();\n            /*if ($P.IE) {*/cleanup();/*}*/\n        };\n        img.src = moduleName;\n\n        return returnResult;\n/*if ($P.WORKER || $P.NODE) {*///#JSCOVERAGE_ENDIF/*}*/\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/js.js":"/**\n * Async loader of js files (NOT LMD modules): jQuery, d3.js etc\n *\n * Flag \"js\"\n *\n * This plugin provides require.js() function\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * Loads any JavaScript file a non-LMD module\n     *\n     * @param {String|Array} moduleName path to file\n     * @param {Function}     [callback]   callback(result) undefined on error HTMLScriptElement on success\n     */\n    sb.require.js = function (moduleName, callback) {\n        var replacement = sb.trigger('*:request-off-package', moduleName, callback, 'js'), // [[returnResult, moduleName, module, true], callback, type]\n            returnResult = replacement[0][0];\n\n        if (replacement[0][3]) { // isReturnASAP\n            return returnResult;\n        }\n\n        var module = replacement[0][2],\n            readyState = 'readyState';\n\n        callback = replacement[1];\n        moduleName = replacement[0][1];\n\n        // by default return undefined\n        if (!sb.document) {\n            module = sb.trigger('js:request-environment-module', moduleName, module)[1];\n            callback(module);\n            return returnResult;\n        }\n\n/*if ($P.WORKER || $P.NODE) {*///#JSCOVERAGE_IF 0/*}*/\n        sb.trigger('*:load-script', moduleName, callback);\n\n        return returnResult;\n/*if ($P.WORKER || $P.NODE) {*///#JSCOVERAGE_ENDIF/*}*/\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/match.js":"/**\n * Matches in-package modules\n *\n * Flag \"match\"\n *\n * This plugin provides require.match() function\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n    var inPackageModules = sb.modules;\n\n    /**\n     * Matches in-package modules\n     *\n     * @param {RegExp} regExp\n     *\n     * @returns {Object} {module_name: module_content}\n     */\n    sb.require.match = function (regExp) {\n        if (!(regExp instanceof RegExp)) {\n            return null;\n        }\n        var result = {};\n\n        for (var moduleName in inPackageModules) {\n            if (regExp.test(moduleName)) {\n                result[moduleName] = sb.require(moduleName);\n            }\n        }\n\n        return result;\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/node.js":"/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * @event async:require-environment-file requests file register using some environment functions non XHR\n     *\n     * @param {String}   moduleName\n     * @param {String}   module\n     * @param {Function} callback   this callback will be called when module inited\n     *\n     * @retuns no\n     */\n    sb.on('preload:require-environment-file', function (moduleName, module, callback) {\n        require('fs').readFile(moduleName, 'utf8', function (err, module) {\n            if (err) {\n                sb.trigger('*:request-error', moduleName);\n                callback();\n                return;\n            }\n            // check file extension - not content-type\n            if ((/js$|json$/).test(moduleName)) {\n                module = sb.trigger('*:wrap-module', moduleName, module, moduleName)[1];\n                if (!(/json$/).test(moduleName)) {\n                    module = sb.trigger('*:coverage-apply', moduleName, module)[1];\n                }\n                module = sb.eval(module);\n            }\n            // 4. Then callback it\n            callback(sb.register(moduleName, module));\n        });\n    });\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/parallel.js":"/**\n * Parallel resource loader\n *\n * Flag \"parallel\"\n *\n * This plugin provides private \"parallel\" function\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n\nfunction parallel(method, items, callback) {\n    var i = 0,\n        j = 0,\n        c = items.length,\n        results = [],\n        ready;\n\n    var readyFactory = function (index) {\n        return function (data) {\n            // keep the order\n            results[index] = data;\n            j++;\n            if (j >= c) {\n                callback.apply(sb.global, results);\n            }\n        }\n    };\n\n    for (; i < c; i++) {\n        ready = readyFactory(i);\n        method(items[i], ready)/*if ($P.PROMISE) {*/.then(ready, ready)/*}*/;\n    }\n}\n\n    /**\n     * @event *:request-parallel parallel module request for require.async(['a', 'b', 'c']) etc\n     *\n     * @param {Array}    moduleNames list of modules to init\n     * @param {Function} callback    this callback will be called when module inited\n     * @param {Function} method      method to call for init\n     *\n     * @retuns yes empty environment\n     */\nsb.on('*:request-parallel', function (moduleNames, callback, method) {\n    parallel(method, moduleNames, callback);\n    return [];\n});\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/preload.js":"/**\n * Async loader of off-package LMD modules (special LMD format file)\n *\n * @see /README.md near \"LMD Modules types\" for details\n *\n * Flag \"async\"\n *\n * This plugin provides require.preload() function\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * Load off-package LMD module\n     *\n     * @param {String|Array} moduleName same origin path to LMD module\n     * @param {Function}     [callback]   callback(result) undefined on error others on success\n     */\n    sb.require.preload = function (moduleName, callback) {\n        return sb.trigger('*:preload', moduleName, callback, 'preload')[0];\n    };\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/promise.js":"/**\n * @name sandbox\n */\n(function (sb) {\n\n    var promisePath = sb.options.promise,\n        error = 'Bad deferred ' + sb.options.promise,\n        deferredFunction,\n        name;\n\n    if (typeof promisePath !== \"string\") {\n        throw new Error(error);\n    }\n\n    promisePath = promisePath.split('.');\n    deferredFunction = sb.require(promisePath[0]);\n\n    while (promisePath.length) {\n        name = promisePath.shift();\n        if (typeof deferredFunction[name] !== \"undefined\") {\n            deferredFunction = deferredFunction[name];\n        }\n    }\n\n    if (typeof deferredFunction !== \"function\") {\n        throw new Error(error);\n    }\n\n    /**\n     * @event *:create-promise creates promise\n     */\nsb.on('*:create-promise', function () {\n    var dfd = deferredFunction(),\n        callback = function (argument) {\n            if (typeof argument === \"undefined\") {\n                dfd.reject();\n            } else {\n                dfd.resolve(/*if ($P.PARALLEL) {*/arguments.length === 1 ? /*}*/argument/*if ($P.PARALLEL) {*/ : Array.prototype.slice.call(arguments)/*}*/);\n            }\n        };\n\n    return [callback, typeof dfd.promise === \"function\" ? dfd.promise() : dfd.promise];\n});\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/race.js":"/**\r\n * This plugin prevents from duplicate resource loading\r\n *\r\n * Flag \"race\"\r\n *\r\n * This plugin provides private \"race_callbacks\" function\r\n */\r\n\r\n/**\r\n * @name sandbox\r\n */\r\n(function (sb) {\r\n\r\nvar race_callbacks = {},\r\n    /**\r\n     * Creates race.\r\n     *\r\n     * @param {String}   name     race name\r\n     * @param {Function} callback callback\r\n     */\r\n    create_race = function (name, callback) {\r\n        if (!race_callbacks[name]) {\r\n            // create race\r\n            race_callbacks[name] = [];\r\n        }\r\n        race_callbacks[name].push(callback);\r\n\r\n        return function (result) {\r\n            var callbacks = race_callbacks[name];\r\n            while(callbacks && callbacks.length) {\r\n                callbacks.shift()(result);\r\n            }\r\n            // reset race\r\n            race_callbacks[name] = false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @event *:request-race race module request eg for cases when some async modules are required simultaneously\r\n     *\r\n     * @param {String}   moduleName race for module name\r\n     * @param {Function} callback   this callback will be called when module inited\r\n     *\r\n     * @retuns yes returns callback if race is empty or only 1 item in it\r\n     */\r\nsb.on('*:request-race', function (moduleName, callback) {\r\n    callback = create_race(moduleName, callback);\r\n    if (race_callbacks[moduleName].length > 1) {\r\n        return [moduleName];\r\n    } else {\r\n        return [moduleName, callback];\r\n    }\r\n});\r\n\r\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/shortcuts.js":"/**\n * This plugin enables shortcuts\n *\n * Flag \"shortcuts\"\n *\n * This plugin provides private \"is_shortcut\" function\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n\nfunction is_shortcut(moduleName, moduleContent) {\n    return !sb.initialized[moduleName] &&\n           typeof moduleContent === \"string\" &&\n           moduleContent.charAt(0) == '@';\n}\n\nfunction rewrite_shortcut(moduleName, module) {\n    if (is_shortcut(moduleName, module)) {\n        sb.trigger('shortcuts:before-resolve', moduleName, module);\n\n        moduleName = module.replace('@', '');\n        // #66 Shortcut self reference should be resolved as undefined->global name\n        var newModule = sb.modules[moduleName];\n        module = newModule === module ? sb.undefined : newModule;\n    }\n    return [moduleName, module];\n}\n\n    /**\n     * @event *:rewrite-shortcut request for shortcut rewrite\n     *\n     * @param {String} moduleName race for module name\n     * @param {String} module     this callback will be called when module inited\n     *\n     * @retuns yes returns modified moduleName and module itself\n     */\nsb.on('*:rewrite-shortcut', rewrite_shortcut);\n\n    /**\n     * @event *:rewrite-shortcut fires before stats plugin counts require same as *:rewrite-shortcut\n     *        but without triggering shortcuts:before-resolve event\n     *\n     * @param {String} moduleName race for module name\n     * @param {String} module     this callback will be called when module inited\n     *\n     * @retuns yes returns modified moduleName and module itself\n     */\nsb.on('stats:before-require-count', function (moduleName, module) {\n    if (is_shortcut(moduleName, module)) {\n        moduleName = module.replace('@', '');\n        module = sb.modules[moduleName];\n\n        return [moduleName, module];\n    }\n});\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/stats_auto.js":"/**\n * Coverage for off-package LMD modules\n *\n * Flag \"stats_auto\"\n *\n * This plugin depends on stats and stats_sendto\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n    var timeout,\n        host = sb.options.stats_host;\n\n    if (!host) return;\n\n    if (host === true) {\n        host = 'http://' + sb.global.location.hostname + ':8081';\n    }\n\n    function updateStats() {\n        if (timeout) return;\n\n        timeout = setTimeout(function () {\n            sb.require.stats.sendTo(host);\n            timeout = 0;\n        }, 2000);\n    }\n\n    function registerCallbacks() {\n        var events = 'click0keyup0orientationchange0resize0scroll0focus'.split(0);\n        for (var i = 0, c = events.length; i < c; i++) {\n            sb.document.body.addEventListener(events[i], updateStats, false);\n        }\n    }\n\n    var interval = sb.global.setInterval(function () {\n        if (sb.document.body) {\n            sb.global.clearInterval(interval);\n            registerCallbacks();\n        }\n    }, 100);\n\n    sb.on('*:before-check', updateStats);\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/stats.js":"/**\r\n * Package usage statistics\r\n *\r\n * @see /README.md near \"Application statistics. Require, load, eval, call statistics\" for details\r\n *\r\n * Flag \"stats\"\r\n *\r\n * This plugin provides require.stats() function and bunch of private functions\r\n */\r\n\r\n\r\n/**\r\n * @name LineReport\r\n * @type {Object}\r\n *\r\n * @property {Boolean}  lines        if false -> not called\r\n * @property {Array[]}  conditions   list of unused conditions [[0, 2], [7, 0]]\r\n * @property {String[]} functions    list of unused functions in that line\r\n */\r\n\r\n/**\r\n * @name TypeReport\r\n * @type {Object}\r\n *\r\n * @property {Number} total\r\n * @property {Number} covered\r\n * @property {Number} percentage\r\n */\r\n\r\n/**\r\n * @name LmdCoverage\r\n * @type {Object}\r\n *\r\n * @property {TypeReport}   lines\r\n * @property {TypeReport}   conditions\r\n * @property {TypeReport}   functions\r\n *\r\n * @property {Object}       report        {lineNum: LineReport}\r\n */\r\n\r\n/**\r\n * @name lmdStats\r\n * @type {Object}\r\n *\r\n * @property {String}       name            module name\r\n * @property {Object}       moduleAccessTimes  module access times {byModuleName: accessTimes}\r\n * @property {Number[]}     accessTimes     access times\r\n * @property {Number}       initTime        module init time: load+eval+call\r\n * @property {String[]}     shortcuts       list of used shortcuts\r\n *\r\n * @property {String}       type            module type: global, in-package, off-package\r\n *\r\n * @property {String[]}     lines           list of all statements\r\n * @property {String[]}     conditions      list of all conditions\r\n * @property {String[]}     functions       list of all functions\r\n *\r\n * @property {Object}       runLines          {lineId: callTimes}\r\n * @property {Object}       runConditions     {conditionId: [falseTimes, trueTimes]}\r\n * @property {Object}       runFunctions      {functionId: callTimes}\r\n *\r\n * @property {LmdCoverage} coverage\r\n *\r\n * @example\r\n *  {\r\n *      name: \"pewpew\",\r\n *      type: \"in-package\",\r\n *      accessTimes: [0],\r\n *      moduleAccessTimes: [{\r\n *          time: 0,\r\n *          byModule: \"main\"\r\n *      }],\r\n *      initTime: 10,\r\n *      shortcuts: [\"ololo\"],\r\n *\r\n *      lines: [\"4\", \"5\", \"8\"],\r\n *      conditions: [\"4:1\", \"5:2\"],\r\n *      functions: [\"FunctionName:5:1\", \"FunctionName2:9:1\"],\r\n *\r\n *      runLines: {\r\n *          \"4\": 1\r\n *          \"5\": 0,\r\n *          \"8\": 14\r\n *      },\r\n *\r\n *      runConditions: {\r\n *          \"4:1\": [1, 0],\r\n *          \"5:2\": [0, 0]\r\n *      },\r\n *\r\n *      runFunctions: {\r\n *          \"FunctionName:5:1\": 10\r\n *          \"FunctionName2:9:1\": 0\r\n *      }\r\n *\r\n *      coverage: {\r\n *          lines: {\r\n *              total: 3,\r\n *              covered: 2,\r\n *              percentage: 66.66667\r\n *          },\r\n *\r\n *          conditions: {\r\n *              total: 2,\r\n *              covered: 0.5,\r\n *              percentage: 25\r\n *          },\r\n *\r\n *          functions: {\r\n *              total: 2,\r\n *              covered: 1,\r\n *              percentage: 50\r\n *          },\r\n *\r\n *          report: {\r\n *              \"4\": {\r\n *                  conditions: [[1, 0]]\r\n *              },\r\n *              \"5\": {\r\n *                  lines: false,\r\n *                  conditions: [[0, 0]]\r\n *              },\r\n *              \"9\": {\r\n *                  functions: [\"FunctionName2\"]\r\n *              }\r\n *          }\r\n *      }\r\n *  }\r\n */\r\n\r\n/**\r\n * @name sandbox\r\n */\r\n(function (sb) {\r\n\r\n/**\r\n * @type {lmdStats}\r\n */\r\nvar stats_results = {},\r\n    stats_Date = sb.global.Date,\r\n    stats_startTime = +new stats_Date;\r\n\r\nfunction stats_get(moduleName) {\r\n    return stats_results[moduleName] ?\r\n           stats_results[moduleName] :\r\n           stats_results[moduleName] = {\r\n               name: moduleName,\r\n               accessTimes: [],\r\n               moduleAccessTimes: {},\r\n               initTime: -1\r\n           };\r\n}\r\n\r\nfunction stats_initStart(moduleName) {\r\n    stats_get(moduleName).initTime = +new stats_Date;\r\n}\r\n\r\nfunction stats_initEnd(moduleName) {\r\n    var stat = stats_get(moduleName);\r\n    stat.initTime = +new stats_Date - stat.initTime;\r\n}\r\n\r\nfunction stats_require(moduleName) {\r\n    var stat = stats_get(moduleName);\r\n    stat.accessTimes.push(+new stats_Date - stats_startTime);\r\n}\r\n\r\nfunction stats_require_module(moduleName, byModuleName) {\r\n    var stat = stats_get(moduleName);\r\n\r\n    if (!stat.moduleAccessTimes[byModuleName]) {\r\n        stat.moduleAccessTimes[byModuleName] = [];\r\n    }\r\n    stat.moduleAccessTimes[byModuleName].push(+new stats_Date - stats_startTime);\r\n}\r\n\r\nfunction stats_wrap_require_method(method, thisObject, byModuleName) {\r\n    return function (moduleName) {\r\n        stats_require_modules(moduleName, byModuleName);\r\n        return method.apply(thisObject, arguments);\r\n    }\r\n}\r\n\r\nfunction stats_require_modules(moduleName, byModuleName) {\r\n    var moduleNames = [];\r\n    if (Object.prototype.toString.call(moduleName) !== \"[object Array]\") {\r\n        moduleNames = [moduleName];\r\n    } else {\r\n        moduleNames = moduleName;\r\n    }\r\n\r\n    for (var i = 0, c = moduleNames.length, moduleNamesItem, module; i < c; i++) {\r\n        moduleNamesItem = moduleNames[i];\r\n        module = sb.modules[moduleNamesItem];\r\n\r\n        var replacement = sb.trigger('stats:before-require-count', moduleNamesItem, module);\r\n        if (replacement) {\r\n            moduleNamesItem = replacement[0];\r\n        }\r\n        stats_require_module(moduleNamesItem, byModuleName);\r\n    }\r\n}\r\n\r\nfunction stats_wrap_require(require, byModuleName) {\r\n    var wrappedRequire = stats_wrap_require_method(require, this, byModuleName);\r\n\r\n    for (var name in require) {\r\n        wrappedRequire[name] = require[name];\r\n    }\r\n\r\n    if (require.async) {\r\n        wrappedRequire.async = stats_wrap_require_method(require.async, this, byModuleName);\r\n    }\r\n\r\n    if (require.css) {\r\n        wrappedRequire.css = stats_wrap_require_method(require.css, this, byModuleName);\r\n    }\r\n\r\n    if (require.js) {\r\n        wrappedRequire.js = stats_wrap_require_method(require.js, this, byModuleName);\r\n    }\r\n\r\n    return wrappedRequire;\r\n}\r\n\r\nfunction stats_type(moduleName, type) {\r\n    var stat = stats_get(moduleName);\r\n    stat.type = type;\r\n}\r\n\r\nfunction stats_shortcut(moduleName, shortcut) {\r\n    var module = stats_get(moduleName.replace('@', '')),\r\n        shortcuts = module.shortcuts,\r\n        index;\r\n    \r\n    if (!shortcuts) {\r\n        shortcuts = module.shortcuts = [];\r\n    }\r\n\r\n    // Link shortcut and real module\r\n    if (!stats_results[shortcut]) {\r\n        stats_results[shortcut] = module;\r\n    }\r\n\r\n    // ie6 indexOf hackz\r\n    index = sb.trigger('*:request-indexof', [].indexOf)[0].call(shortcuts, shortcut);\r\n\r\n    if (index === -1) {\r\n        shortcuts.push(shortcut);\r\n    }\r\n}\r\n\r\n/**\r\n * Returns module statistics or all statistics\r\n *\r\n * @param {String} [moduleName]\r\n * @return {Object}\r\n */\r\nsb.require.stats = function (moduleName) {\r\n    var replacement = sb.trigger('stats:before-return-stats', moduleName, stats_results);\r\n\r\n    if (replacement && replacement[1]) {\r\n        return replacement[1];\r\n    }\r\n    return moduleName ? stats_results[moduleName] : stats_results;\r\n};\r\n\r\n    /**\r\n     * @event lmd-register:decorate-require request for fake require\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     *\r\n     * @retuns yes wraps require\r\n     */\r\nsb.on('lmd-register:decorate-require', function (moduleName, require) {\r\n    var options = sb.modules_options[moduleName] || {};\r\n    if (options.sandbox) {\r\n        return;\r\n    }\r\n    return [moduleName, stats_wrap_require(require, moduleName)];\r\n});\r\n\r\n    /**\r\n     * @event lmd-register:after-register after module register event\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('lmd-register:after-register', function (moduleName) {\r\n    stats_initEnd(moduleName);\r\n});\r\n\r\n    /**\r\n     * @event lmd-register:before-register before module register event\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('lmd-register:before-register', function (moduleName, module) {\r\n    stats_type(moduleName, !module ? 'global' : typeof sb.modules[moduleName] === \"undefined\" ? 'off-package' : 'in-package');\r\n});\r\n\r\n    /**\r\n     * @event *:before-check before module cache check\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     * @param {String} type\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('*:before-check', function (moduleName, module, type) {\r\n    switch (type) {\r\n        case \"css\":\r\n            if (!(module || !sb.document) || sb.initialized[moduleName]) {\r\n                stats_require(moduleName);\r\n            }\r\n            break;\r\n        case \"js\":\r\n        case \"async\":\r\n            if (!module || sb.initialized[moduleName]) {\r\n                stats_require(moduleName);\r\n            }\r\n            break;\r\n        default:\r\n            stats_require(moduleName);\r\n    }\r\n});\r\n\r\n    /**\r\n     * @event *:before-init calls when module is goint to eval or call\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('*:before-init', function (moduleName) {\r\n    stats_initStart(moduleName);\r\n});\r\n\r\n    /**\r\n     * @event *:request-error module load error\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('*:request-error', function (moduleName) {\r\n    stats_initEnd(moduleName);\r\n});\r\n\r\n    /**\r\n     * @event shortcuts:before-resolve moduleName is shortcut and its goint to resolve with actual name\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} module\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('shortcuts:before-resolve', function (moduleName, module) {\r\n    // assign shortcut name for module\r\n    stats_shortcut(module, moduleName);\r\n});\r\n\r\n    /**\r\n     * @event *:stats-get somethins is request raw module stats\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} result    default stats\r\n     *\r\n     * @retuns yes\r\n     */\r\nsb.on('*:stats-get', function (moduleName, result) {\r\n    return [moduleName, stats_get(moduleName)];\r\n});\r\n\r\n    /**\r\n     * @event *:stats-type something tells stats to overwrite module type\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {String} packageType\r\n     *\r\n     * @retuns no\r\n     */\r\nsb.on('*:stats-type', function (moduleName, packageType) {\r\n    stats_type(moduleName, packageType);\r\n});\r\n\r\n    /**\r\n     * @event *:stats-results somethins is request processed module stats\r\n     *\r\n     * @param {String} moduleName\r\n     * @param {Object} result     default stats\r\n     *\r\n     * @retuns yes\r\n     */\r\nsb.on('*:stats-results', function (moduleName, result) {\r\n    return [moduleName, stats_results[moduleName]];\r\n});\r\n\r\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/stats_sendto.js":"/**\n * Coverage for off-package LMD modules\n *\n * Flag \"stats_sendto\"\n *\n * This plugin provides sendTo private function and require.stats.sendTo() public function\n *\n * This plugin depends on stats\n */\n/**\n * @name sandbox\n */\n(function (sb) {\n\n/**\n  * XDomain post\n  *\n  * @param {String} host\n  * @param {String} method\n  * @param {Object} data\n  * @param {String} [reportName]\n  *\n  */\nvar sendTo = function () {\n    var runId = function () {\n            var userAgent = navigator.userAgent,\n                rchrome = /(chrome)[ \\/]([\\w.]+)/i,\n                rwebkit = /(webkit)[ \\/]([\\w.]+)/i,\n                ropera = /(opera)(?:.*version)?[ \\/]([\\w.]+)/i,\n                rmsie = /(msie) ([\\w.]+)/i,\n                rmozilla = /(mozilla)(?:.*? rv:([\\w.]+))?/i;\n\n            userAgent = (userAgent.match(rchrome) ||\n                userAgent.match(rwebkit) ||\n                userAgent.match(ropera) ||\n                userAgent.match(rmsie) ||\n                userAgent.match(rmozilla)\n            );\n\n            return (userAgent ? userAgent.slice(1).join('-') : 'undefined-0') + '-' +\n                   (new Date+'').split(' ').slice(1, 5).join('_') + '-' +\n                   Math.random();\n        }();\n\n    /**\n     * @return {HTMLIFrameElement}\n     */\n    return function (host, method, data, reportName) {\n        var JSON = sb.trigger('*:request-json', sb.global.JSON)[0];\n\n        // Add the iframe with a unique name\n        var iframe = sb.document.createElement(\"iframe\"),\n            uniqueString = sb.global.Math.random();\n\n        sb.document.body.appendChild(iframe);\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"absolute\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"-1000px\";\n        iframe.contentWindow.name = uniqueString;\n\n        // construct a form with hidden inputs, targeting the iframe\n        var form = sb.document.createElement(\"form\");\n        form.target = uniqueString;\n        form.action = host + \"/\" + method + '/' + (reportName || runId).replace(/\\/|\\\\|\\./g, '_');\n        form.method = \"POST\";\n        form.setAttribute('accept-charset', 'utf-8');\n\n        // repeat for each parameter\n        var input = sb.document.createElement(\"input\");\n        input.type = \"hidden\";\n        input.name = \"json\";\n        input.value = JSON.stringify(data);\n        form.appendChild(input);\n\n        document.body.appendChild(form);\n        form.submit();\n\n        return iframe;\n    }\n}();\n\nsb.require.stats.sendTo = function (host) {\n    return sendTo(host, \"stats\", sb.require.stats());\n};\n\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/stats_server/lib/admin.js":"/**\n * This code was originally made by Fabio Crisci and distributed under MIT licence\n *\n * Copyright (c) 2012 Fabio Crisci <fabio.crisci@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nvar fs = require(\"fs\"),\n    path = require('path'),\n    util = require(\"util\"),\n    express = require('express');\n\nexports.attachTo = function (app, logDir, wwwDir, lmdConfig, lmdModules) {\n\tapp.set(\"view engine\", \"jade\");\n\tapp.set(\"view options\", {\n\t\tlayout: false\n\t});\n\n\tapp.set(\"views\", __dirname + \"/../views\");\n\tapp.use(express.static(__dirname + \"/../views/statics\"));\n\n    // list all coverage reports\n\tapp.get(\"/\", function (req, res) {\n\t\tfs.readdir(logDir, function (err, files) {\n\t\t\tif (err) {\n\t\t\t\tres.send(\"Error while reading directory \" + logDir, 404);\n\t\t\t} else {\n\t\t\t\tvar reports = [];\n\t\t\t\tfiles.forEach(function (file) {\n\t\t\t\t\treports.push({\n\t\t\t\t\t\tid : file,\n\t\t\t\t\t\tdate : fs.statSync(path.join(logDir, file)).ctime + ''\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treports.sort(function (first, second) {\n\t\t\t\t\tvar timeOne = first.time;\n\t\t\t\t\tvar timeTwo = second.time;\n\t\t\t\t\tif (timeOne == timeTwo) {\n\t\t\t\t\t\t// rly ?\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn timeOne < timeTwo ? 1 : -1;\n\t\t\t\t});\n                res.render(\"admin\", {\n                    reports : reports\n                });\n\t\t\t}\n\t\t});\n\t});\n\n\tapp.get(\"/report/:report\", function (req, res) {\n\t\treadReport(req.params.report, sendReport.bind(this, req, res));\n\t});\n\n\tapp.get(\"/report/:report/module/:moduleName\", function (req, res) {\n\t\tvar moduleName = req.params.moduleName,\n            fileName;\n        // lmd module name -> path|shortcut\n        if (lmdModules[moduleName]) {\n            fileName = lmdModules[moduleName].path;\n        } else {\n            // www_path -> path\n            fileName = path.join(wwwDir, moduleName);\n        }\n\n        // shortcut -> path\n        if (fileName.charAt(0) === '@') {\n            fileName = path.join(wwwDir, fileName.replace('@', ''));\n        }\n\t\treadReport(req.params.report, function (err, report) {\n\t\t\tif (err) {\n\t\t\t\tres.send(500);\n\t\t\t} else {\n                var module_report = report.modules[moduleName];\n\n                if (module_report.type !== \"global\") {\n                    var code = getCode(moduleName),\n                        lines = code.split('\\n');\n                }\n\n                res.render(\"file\", {\n                    name: req.params.report,\n                    module: moduleName,\n                    report: module_report,\n                    full_report: report,\n                    code: code,\n                    lines: lines && lines.length,\n                    options: {\n                        highlight: 'idea'\n                    }\n                });\n\t\t\t}\n\t\t});\n\t});\n\n    function getCode(moduleName) {\n        var fileName;\n        // lmd module name -> path|shortcut\n        if (lmdModules[moduleName]) {\n            fileName = lmdModules[moduleName].path;\n        } else {\n            // www_path -> path\n            fileName = path.join(wwwDir, moduleName);\n        }\n\n        // shortcut -> path\n        if (fileName.charAt(0) === '@') {\n            fileName = path.join(wwwDir, fileName.replace('@', ''));\n        }\n\n        return fs.readFileSync(fileName, 'utf8');\n    }\n\n\tfunction readReport(report, callback) {\n\t\tfs.readFile(path.join(logDir, report), function (err, data) {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t\tcallback.call(null, err);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tvar result = JSON.parse(data);\n\t\t\t\t\tcallback.call(null, false, result);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tconsole.error(ex);\n\t\t\t\t\tcallback.call(null, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n    function getSuggestions(report) {\n        var moduleReport,\n            byModuleReport,\n            lmdModuleOptions,\n            realModuleName,\n            realByModuleName,\n            suggestions = [];\n\n        for (var moduleName in report.modules) {\n            moduleReport = report.modules[moduleName];\n            lmdModuleOptions = lmdConfig.modules[moduleName];\n            realModuleName = moduleReport && moduleReport.shortcuts && moduleReport.shortcuts.length ? moduleReport.shortcuts.join(', ') : moduleName;\n\n            // config exists and module is not a shortcut\n            if (moduleReport && moduleName === moduleReport.name && moduleName !== \"main\") {\n                // #1 If module lazy and it is requires on start add Suggestion\n                if (lmdModuleOptions &&\n                    lmdModuleOptions.is_lazy &&\n                    moduleReport.accessTimes &&\n                    moduleReport.accessTimes.length &&\n                    moduleReport.accessTimes[0] < 1000) {\n\n                    suggestions.push(util.format(\n                        'Module \"%s\" is lazy, but it accessed at application start (%d ms) you can make it not lazy to reduce a bit startup latency',\n                        realModuleName, moduleReport.accessTimes[0]\n                    ));\n                }\n\n                // #4 If module starts after 5000ms and not lazy - suggest to make it lazy\n                if (lmdModuleOptions &&\n                    !lmdModuleOptions.is_lazy &&\n                    moduleReport.accessTimes &&\n                    moduleReport.accessTimes.length &&\n                    moduleReport.accessTimes[0] > 5000) {\n\n                    suggestions.push(util.format(\n                        'Module \"%s\" is not lazy, but it runs lazily in your application (%d ms) you can make it lazy to reduce a bit startup latency',\n                        realModuleName, moduleReport.accessTimes[0]\n                    ));\n                }\n\n                // #2 If some module includes other module more than 2 times\n                if (moduleReport.moduleAccessTimes) {\n                    for (var byModuleName in moduleReport.moduleAccessTimes) {\n                        byModuleReport = report.modules[byModuleName];\n                        realByModuleName = byModuleReport && byModuleReport.shortcuts && byModuleReport.shortcuts.length ? byModuleReport.shortcuts.join(', ') : byModuleName;\n\n                        if (moduleReport.moduleAccessTimes[byModuleName].length > 1) {\n                            suggestions.push(util.format(\n                                'Module \"%s\" is required by module \"%s\" %d times',\n                                realModuleName, realByModuleName, moduleReport.moduleAccessTimes[byModuleName].length\n                            ));\n                        }\n                    }\n                }\n\n                // #3 Suggest to create shortcuts instead of using urls\n                if (moduleReport.type === \"off-package\" && moduleReport && moduleReport.shortcuts && moduleReport.shortcuts.length === 0) {\n                    suggestions.push(util.format(\n                        'You can give shortcut name to your off-package module \"%s\" like \"some_name\": \"@%s\"',\n                        realModuleName, realModuleName\n                    ));\n                }\n\n                // #5 Mark unused module (Module in not used?)\n                if (lmdModuleOptions && moduleReport.accessTimes && moduleReport.accessTimes.length === 0) {\n                    suggestions.push(util.format(\n                        'Module \"%s\" is not used. You can make it off-package to reduce file size',\n                        realModuleName\n                    ));\n                }\n            }\n        }\n\n        return suggestions;\n    }\n\n\tfunction sendReport(req, res, err, report, name) {\n\t\tif (err) {\n\t\t\tres.send(500);\n\t\t} else {\n            var imports = [],\n                rawImports = {};\n\n            for (var moduleName in report.modules) {\n                var moduleStats = report.modules[moduleName];\n                if (moduleStats.name === moduleName) {\n                    if (!rawImports[moduleName]) {\n                        rawImports[moduleName] = {\n                            \"name\": moduleName,\n                            \"size\": 0,\n                            \"imports\": []\n                        };\n                        imports.push(rawImports[moduleName]);\n                    }\n                    for (var ownerModuleName in moduleStats.moduleAccessTimes) {\n                        if (!rawImports[ownerModuleName]) {\n                            rawImports[ownerModuleName] = {\n                                \"name\": ownerModuleName,\n                                \"size\": 0,\n                                \"imports\": []\n                            };\n                            imports.push(rawImports[ownerModuleName]);\n                        }\n                        rawImports[ownerModuleName].size++;\n                        rawImports[ownerModuleName].imports.push(moduleName);\n                    }\n                }\n            }\n\n            res.render(\"report\", {\n                name : name || req.params.report,\n                report : report,\n                imports_report_data: JSON.stringify(imports),\n                suggestions: getSuggestions(report)\n            });\n\t\t}\n\t}\n};","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/common/off_package.js":"/**\n * @name sandbox\n */\n(function (sb) {\n    var domOnlyLoaders = {\n        'css': true,\n        'image': true\n    };\n\n    var reEvalable = /(java|ecma)script|json/,\n        reJson = /json/;\n\n    /**\n      * Load off-package LMD module\n      *\n      * @param {String|Array} moduleName same origin path to LMD module\n      * @param {Function}     [callback]   callback(result) undefined on error others on success\n      */\n    sb.on('*:preload', function (moduleName, callback, type) {\n        var replacement = sb.trigger('*:request-off-package', moduleName, callback, type), // [[returnResult, moduleName, module, true], callback, type]\n            returnResult = [replacement[0][0], callback, type];\n\n        if (replacement[0][3]) { // isReturnASAP\n            return returnResult;\n        }\n\n        var module = replacement[0][2],\n            XMLHttpRequestConstructor = sb.global.XMLHttpRequest || sb.global.ActiveXObject;\n\n        callback = replacement[1];\n        moduleName = replacement[0][1];\n\n        if (!XMLHttpRequestConstructor) {\n            sb.trigger('preload:require-environment-file', moduleName, module, callback);\n            return returnResult;\n        }\n/*if ($P.NODE) {*///#JSCOVERAGE_IF 0/*}*/\n        // Optimized tiny ajax get\n        // @see https://gist.github.com/1625623\n        var xhr = new XMLHttpRequestConstructor(\"Microsoft.XMLHTTP\");\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                // 3. Check for correct status 200 or 0 - OK?\n                if (xhr.status < 201) {\n                    var contentType = xhr.getResponseHeader('content-type');\n                    module = xhr.responseText;\n                    if (reEvalable.test(contentType)) {\n                        module = sb.trigger('*:wrap-module', moduleName, module, contentType)[1];\n                        if (!reJson.test(contentType)) {\n                            module = sb.trigger('*:coverage-apply', moduleName, module)[1];\n                        }\n\n                        sb.trigger('preload:before-callback', moduleName, module);\n                        module = sb.eval(module);\n                    } else {\n                        sb.trigger('preload:before-callback', moduleName, module);\n                    }\n\n                    if (type === 'preload') {\n                        // 4. Declare it\n                        sb.modules[moduleName] = module;\n                        // 5. Then callback it\n                        callback(moduleName);\n                    } else {\n                        // 4. Callback it\n                        callback(sb.register(moduleName, module));\n                    }\n                } else {\n                    sb.trigger('*:request-error', moduleName, module);\n                    callback();\n                }\n            }\n        };\n        xhr.open('get', moduleName);\n        xhr.send();\n\n        return returnResult;\n/*if ($P.NODE) {*///#JSCOVERAGE_ENDIF/*}*/\n    });\n\n    /**\n     * @event *:request-off-package\n     *\n     * @param {String}   moduleName\n     * @param {Function} callback\n     * @param {String}   type\n     *\n     * @retuns yes [asap, returnResult]\n     */\n    sb.on('*:request-off-package', function (moduleName, callback, type) {\n        /*if ($P.PROMISE) {*/var createPromiseResult = sb.trigger('*:create-promise');/*}*/\n        var returnResult = /*if ($P.PROMISE) {*/createPromiseResult[1] || /*}*/sb.require;\n        callback = /*if ($P.PROMISE) {*/createPromiseResult[0] || /*}*/callback || sb.noop;\n\n        if (typeof moduleName !== \"string\") {\n            callback = sb.trigger('*:request-parallel', moduleName, callback, sb.require[type])[1];\n            if (!callback) {\n                return [[returnResult, moduleName, module, true], callback, type];\n            }\n        }\n\n        var module = sb.modules[moduleName];\n\n        var replacement = sb.trigger('*:rewrite-shortcut', moduleName, module);\n        if (replacement) {\n            moduleName = replacement[0];\n            module = replacement[1];\n        }\n\n        sb.trigger('*:before-check', moduleName, module, type);\n        // If module exists or its a node.js env\n        if (module || (domOnlyLoaders[type] && !sb.document)) {\n            callback(type === \"preload\" ? moduleName : sb.initialized[moduleName] ? module : sb.require(moduleName));\n            return [[returnResult, moduleName, module, true], callback, type];\n        }\n\n        sb.trigger('*:before-init', moduleName, module);\n\n        callback = sb.trigger('*:request-race', moduleName, callback)[1];\n        // if already called\n        if (!callback) {\n            return [[returnResult, moduleName, module, true], callback, type]\n        }\n\n        return [[returnResult, moduleName, module, false], callback, type];\n    });\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/common/script_loader.js":"/**\n * Internal module\n */\n\n/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * Loads any JavaScript file a non-LMD module\n     *\n     * @param {String|Array} moduleName path to file\n     * @param {Function}     [callback]   callback(result) undefined on error HTMLScriptElement on success\n     */\n    sb.on('*:load-script', function (moduleName, callback) {\n        var readyState = 'readyState',\n            isNotLoaded = 1,\n            head;\n\n        var script = sb.document.createElement(\"script\");\n        sb.global.setTimeout(script.onreadystatechange = script.onload = function (e) {\n            e = e || sb.global.event;\n            if (isNotLoaded &&\n                (!e ||\n                !script[readyState] ||\n                script[readyState] == \"loaded\" ||\n                script[readyState] == \"complete\")) {\n\n                isNotLoaded = 0;\n                // register or cleanup\n                if (!e) {\n                    sb.trigger('*:request-error', moduleName);\n                }\n                callback(e ? sb.register(moduleName, script) : head.removeChild(script) && sb.undefined); // e === undefined if error\n            }\n        }, 3000, 0);\n\n        script.src = moduleName;\n        head = sb.document.getElementsByTagName(\"head\")[0];\n        head.insertBefore(script, head.firstChild);\n\n        return [moduleName, callback];\n    });\n\n}(sandbox));\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/common/worker_or_node.js":"/**\n * @name sandbox\n */\n(function (sb) {\n    /**\n     * @event js:request-environment-module js.js plugin requests for enviroment-based module init\n     *        (importScripts or node require)\n     *\n     * @param {String}   moduleName\n     * @param {String}   module\n     *\n     * @retuns yes\n     */\n    sb.on('js:request-environment-module', function (moduleName, module) {\n        try {\n            // call importScripts or require\n            // any of them can throw error if file not found or transmission error\n            module = sb.modules[moduleName] = (sb.global.importScripts || require)(moduleName) || {};\n            return [moduleName, module];\n        } catch (e) {\n            // error -> default behaviour\n            sb.trigger('*:request-error', moduleName, module);\n            return [moduleName, module];\n        }\n    });\n}(sandbox));","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/src/plugin/common/wrap_module.js":"/**\n * @name sandbox\n */\n(function (sb) {\n\nif ($P.WRAP_MODULE) {\n\n    /**\n     * @param code\n     * @return {Boolean} true if it is a plain LMD module\n     */\n    var async_is_plain_code = function (code) {\n        // remove comments (bad rx - I know it, but it works for that case), spaces and ;\n        code = code.replace(/\\/\\*.*?\\*\\/|\\/\\/.*(?=[\\n\\r])|\\s|\\;/g, '');\n\n        // simple FD/FE parser\n        if (/\\(function\\(|function[a-z0-9_]+\\(/.test(code)) {\n            var index = 0,\n                length = code.length,\n                is_can_return = false,\n                string = false,\n                parentheses = 0,\n                braces = 0;\n\n            while (index < length) {\n                switch (code.charAt(index)) {\n                    // count braces if not in string\n                    case '{':\n                        if (!string) {\n                            is_can_return = true;\n                            braces++\n                        }\n                        break;\n                    case '}':\n                        if (!string) braces--;\n                        break;\n\n                    case '(':\n                        if (!string) parentheses++;\n                        break;\n                    case ')':\n                        if (!string) parentheses--;\n                        break;\n\n                    case '\\\\':\n                        if (string) index++; // skip next char in in string\n                        break;\n\n                    case \"'\":\n                        if (string === \"'\") {\n                            string = false; // close string\n                        } else if (string === false) {\n                            string = \"'\"; // open string\n                        }\n                        break;\n\n                    case '\"':\n                        if (string === '\"') {\n                            string = false; // close string\n                        } else if (string === false) {\n                            string = '\"'; // open string\n                        }\n                        break;\n                }\n                index++;\n\n                if (is_can_return && !parentheses && !braces) {\n                    return index !== length;\n                }\n            }\n        }\n        return true;\n    };\n}\n\nvar async_plain = function (module, contentTypeOrExtension) {\n    // its NOT a JSON ant its a plain code\n    if (!(/json/).test(contentTypeOrExtension)/*if ($P.WRAP_MODULE) {*/ && async_is_plain_code(module)/*}*/) {\n        // its not a JSON and its a Plain LMD module - wrap it\n        module = '(function(require,exports,module){\\n' + module + '\\n})';\n    }\n    return module;\n};\n\n    /**\n     * @event *:wrap-module Module wrap request\n     *\n     * @param {String} moduleName\n     * @param {String} module this module will be wrapped\n     * @param {String} contentTypeOrExtension file content type or extension to avoid wrapping json file\n     *\n     * @retuns yes\n     */\nsb.on('*:wrap-module', function (moduleName, module, contentTypeOrExtension) {\n    module = async_plain(module, contentTypeOrExtension);\n    return [moduleName, module, contentTypeOrExtension];\n});\n\n    /**\n     * @event *:is-plain-module code type check request: plain or lmd-module\n     *\n     * @param {String} moduleName\n     * @param {String} module\n     * @param {String} isPlainCode default value\n     *\n     * @retuns yes\n     */\nsb.on('*:is-plain-module', function (moduleName, module, isPlainCode) {\n    if (typeof async_is_plain_code === \"function\") {\n        return [moduleName, module, async_is_plain_code(module)];\n    }\n});\n\n}(sandbox));\n","/home/travis/build/npmtest/node-npmtest-lmd/node_modules/lmd/stats_server/views/statics/main.js":"$(function () {\n    $('.b-notes').find('.b-notes__more')\n        .click(function () {\n            $(this)\n                .siblings('.b-notes__tags_type_more')\n                .show()\n                .end()\n                .replaceWith(', ')\n                ;\n\n            return false;\n        });\n});\n$(function () {\n    if (!$(\".b-require-graph\").length) {\n        return;\n    }\n\n    var packages = {\n\n        // Lazily construct the package hierarchy from class names.\n        root: function(classes) {\n            var map = {};\n\n            function find(name, data) {\n                var node = map[name], i;\n                if (!node) {\n                    node = map[name] = data || {name: name, children: []};\n                    if (name.length) {\n                        node.parent = find(\"\");\n                        node.parent.children.push(node);\n                        node.name = name;\n                        node.key = escapeId(name);\n                    }\n                }\n                return node;\n            }\n\n            classes.forEach(function(d) {\n                find(d.name, d);\n            });\n\n            return map[\"\"];\n        },\n\n        // Return a list of imports for the given array of nodes.\n        imports:function (nodes) {\n            var map = {},\n                imports = [];\n\n            // Compute a map from name to node.\n            nodes.forEach(function (d) {\n                map[d.name] = d;\n            });\n\n            // For each import, construct a link from the source to target node.\n            nodes.forEach(function (d) {\n                if (d.imports) d.imports.forEach(function (i) {\n                    imports.push({\n                        source: map[d.name],\n                        target: map[i]\n                    });\n                });\n            });\n\n            return imports;\n        }\n\n    };\n\n    var w = 800,\n        h = 800,\n        rx = w / 2,\n        ry = h / 2,\n        m0,\n        rotate = 0;\n\n    var splines = [];\n\n    var cluster = d3.layout.cluster()\n        .size([360, ry - 150])\n        .sort(function(a, b) { return d3.ascending(a.key, b.key); });\n\n    var bundle = d3.layout.bundle();\n\n    var line = d3.svg.line.radial()\n        .interpolate(\"bundle\")\n        .tension(.85)\n        .radius(function(d) {\n            return d.y;\n        })\n        .angle(function(d) {\n            return d.x / 180 * Math.PI;\n        });\n\n    // Chrome 15 bug: <http://code.google.com/p/chromium/issues/detail?id=98951>\n    var div = d3.select(\".b-require-graph\");\n\n    var svg_wrapper = div.append(\"svg:svg\")\n        .attr(\"width\", w)\n        .attr(\"height\", h);\n\n    var svg = svg_wrapper.append(\"svg:g\")\n        .attr(\"transform\", \"translate(\" + rx + \",\" + (ry - 100) + \")\");\n\n    var legend = svg_wrapper.append('svg:g')\n        .attr(\"transform\", \"translate(\" + 0 + \",\" + 10 + \")\");\n\n    legend.append('svg:line')\n        .attr('x1', 0)\n        .attr('y1', 0)\n        .attr('x2', 30)\n        .attr('y2', 0)\n        .attr(\"class\", \"link source\");\n\n    legend.append(\"svg:text\")\n        .attr(\"dx\", 35)\n        .attr(\"dy\", 3)\n        .text(\"requires\");\n\n    legend.append('svg:line')\n        .attr('x1', 0)\n        .attr('y1', 15)\n        .attr('x2', 30)\n        .attr('y2', 15)\n        .attr(\"class\", \"link target\");\n\n    legend.append(\"svg:text\")\n        .attr(\"dx\", 35)\n        .attr(\"dy\", 18)\n        .text(\"required by\");\n\n    // <line x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\" style=\"stroke:rgb(255,0,0);stroke-width:2\"/>\n\n    svg.append(\"svg:path\")\n        .attr(\"class\", \"arc\")\n        .attr(\"d\", d3.svg.arc().outerRadius(ry - 120).innerRadius(0).startAngle(0).endAngle(2 * Math.PI))\n        .on(\"mousedown\", mousedown);\n\n    (function (classes) {\n        var nodes = cluster.nodes(packages.root(classes)),\n            links = packages.imports(nodes),\n            splines = bundle(links);\n\n        var path = svg.selectAll(\"path.link\")\n            .data(links)\n            .enter().append(\"svg:path\")\n\n            .attr(\"class\", function (d) {\n                return \"link source-\" + d.source.key + \" target-\" + d.target.key;\n            })\n            .attr(\"d\", function (d, i) {\n                return line(splines[i]);\n            });\n\n        svg.selectAll(\"g.node\")\n            .data(nodes.filter(function (n) {\n                return !n.children;\n            }))\n            .enter().append(\"svg:g\")\n            .attr(\"class\", \"node\")\n            .attr(\"id\", function (d) {\n                return \"node-\" + d.key;\n            })\n            .attr(\"transform\", function (d) {\n                return \"rotate(\" + (d.x - 90) + \")translate(\" + d.y + \")\";\n            })\n            .append(\"svg:text\")\n            .attr(\"dx\", function (d) {\n                return d.x < 180 ? 8 : -8;\n            })\n            .attr(\"dy\", \".31em\")\n            .attr(\"text-anchor\", function (d) {\n                return d.x < 180 ? \"start\" : \"end\";\n            })\n            .attr(\"transform\", function (d) {\n                return d.x < 180 ? null : \"rotate(180)\";\n            })\n            .text(function (d) {\n                return d.name;\n            })\n            .on(\"mouseover\", mouseover)\n            .on(\"mouseout\", mouseout);\n\n        d3.select(\"input[type=range]\").on(\"change\", function () {\n            line.tension(this.value / 100);\n            path.attr(\"d\", function (d, i) {\n                return line(splines[i]);\n            });\n        });\n    }(window.importsReportData));\n\n    d3.select(window)\n        .on(\"mousemove\", mousemove)\n        .on(\"mouseup\", mouseup);\n\n    function escapeId(name) {\n        return name.replace(/\\/|\\./g, '__');\n    }\n\n    function mouse(e) {\n        return [e.pageX - rx, e.pageY - ry];\n    }\n\n    function mousedown() {\n        m0 = mouse(d3.event);\n        d3.event.preventDefault();\n    }\n\n    function mousemove() {\n        if (m0) {\n            var m1 = mouse(d3.event),\n                dm = Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;\n            div.style(\"transform\", \"translate3d(0,\" + (ry - rx) + \"px,0)rotate3d(0,0,0,\" + dm + \"deg)translate3d(0,\" + (rx - ry) + \"px,0)\");\n        }\n    }\n\n    function mouseup() {\n        if (m0) {\n            var m1 = mouse(d3.event),\n                dm = Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;\n\n            rotate += dm;\n            if (rotate > 360) rotate -= 360;\n            else if (rotate < 0) rotate += 360;\n            m0 = null;\n\n            div.style(\"transform\", \"rotate3d(0,0,0,0deg)\");\n\n            svg\n                .attr(\"transform\", \"translate(\" + rx + \",\" + ry + \")rotate(\" + rotate + \")\")\n                .selectAll(\"g.node text\")\n                .attr(\"dx\", function (d) {\n                    return (d.x + rotate) % 360 < 180 ? 8 : -8;\n                })\n                .attr(\"text-anchor\", function (d) {\n                    return (d.x + rotate) % 360 < 180 ? \"start\" : \"end\";\n                })\n                .attr(\"transform\", function (d) {\n                    return (d.x + rotate) % 360 < 180 ? null : \"rotate(180)\";\n                });\n        }\n    }\n\n    function mouseover(d) {\n        svg.selectAll(\"path.link.target-\" + d.key)\n            .classed(\"target\", true)\n            .each(updateNodes(\"source\", true));\n\n        svg.selectAll(\"path.link.source-\" + d.key)\n            .classed(\"source\", true)\n            .each(updateNodes(\"target\", true));\n    }\n\n    function mouseout(d) {\n        svg.selectAll(\"path.link.source-\" + d.key)\n            .classed(\"source\", false)\n            .each(updateNodes(\"target\", false));\n\n        svg.selectAll(\"path.link.target-\" + d.key)\n            .classed(\"target\", false)\n            .each(updateNodes(\"source\", false));\n    }\n\n    function updateNodes(name, value) {\n        return function (d) {\n            if (value) this.parentNode.appendChild(this);\n            svg.select(\"#node-\" + d[name].key).classed(name, value);\n        };\n    }\n\n    function cross(a, b) {\n        return a[0] * b[1] - a[1] * b[0];\n    }\n\n    function dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1];\n    }\n});$(function () {\n    var $source = $('.b-source'),\n        $oldTarget = $();\n\n    $(window).on(\"hashchange\", function () {\n        if ($oldTarget.length) {\n            $oldTarget.removeClass('b-source__line_focused_yes');\n        }\n\n        var hash = window.location.hash;\n        if (hash && hash.length > 2) {\n            hash = hash.charAt(0) === '#' ? hash : '#' + hash;\n            $oldTarget = $source.find(hash);\n            $oldTarget.addClass('b-source__line_focused_yes');\n        }\n    }).trigger(\"hashchange\");\n\n    $source.on('click', '.b-source__line__item_type_line', function () {\n        window.location.hash = '#L' + $(this).text();\n    });\n});\n$(function () {\n    var $el = $('.b-suggestions');\n    $el.find('.js-suggestions-more').click(function () {\n        $el.find('.i-hidden').removeClass('i-hidden');\n        $(this).remove();\n        return false;\n    });\n});"}